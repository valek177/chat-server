// Code generated by http://github.com/gojuno/minimock (v3.4.1). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/valek177/chat-server/internal/service.ChatService -o chat_service_minimock.go -n ChatServiceMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/valek177/chat-server/grpc/pkg/chat_v1"
)

// ChatServiceMock implements mm_service.ChatService
type ChatServiceMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcConnectChat          func(ctx context.Context, chatID int64, username string, stream chat_v1.ChatV1_ConnectChatServer) (err error)
	funcConnectChatOrigin    string
	inspectFuncConnectChat   func(ctx context.Context, chatID int64, username string, stream chat_v1.ChatV1_ConnectChatServer)
	afterConnectChatCounter  uint64
	beforeConnectChatCounter uint64
	ConnectChatMock          mChatServiceMockConnectChat

	funcCreateChat          func(ctx context.Context, req *chat_v1.CreateChatRequest) (i1 int64, err error)
	funcCreateChatOrigin    string
	inspectFuncCreateChat   func(ctx context.Context, req *chat_v1.CreateChatRequest)
	afterCreateChatCounter  uint64
	beforeCreateChatCounter uint64
	CreateChatMock          mChatServiceMockCreateChat

	funcDeleteChat          func(ctx context.Context, id int64) (err error)
	funcDeleteChatOrigin    string
	inspectFuncDeleteChat   func(ctx context.Context, id int64)
	afterDeleteChatCounter  uint64
	beforeDeleteChatCounter uint64
	DeleteChatMock          mChatServiceMockDeleteChat

	funcGetChatIDByName          func(ctx context.Context, chatname string) (i1 int64, err error)
	funcGetChatIDByNameOrigin    string
	inspectFuncGetChatIDByName   func(ctx context.Context, chatname string)
	afterGetChatIDByNameCounter  uint64
	beforeGetChatIDByNameCounter uint64
	GetChatIDByNameMock          mChatServiceMockGetChatIDByName

	funcSendMessage          func(ctx context.Context, chatID int64, message *chat_v1.Message) (err error)
	funcSendMessageOrigin    string
	inspectFuncSendMessage   func(ctx context.Context, chatID int64, message *chat_v1.Message)
	afterSendMessageCounter  uint64
	beforeSendMessageCounter uint64
	SendMessageMock          mChatServiceMockSendMessage
}

// NewChatServiceMock returns a mock for mm_service.ChatService
func NewChatServiceMock(t minimock.Tester) *ChatServiceMock {
	m := &ChatServiceMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ConnectChatMock = mChatServiceMockConnectChat{mock: m}
	m.ConnectChatMock.callArgs = []*ChatServiceMockConnectChatParams{}

	m.CreateChatMock = mChatServiceMockCreateChat{mock: m}
	m.CreateChatMock.callArgs = []*ChatServiceMockCreateChatParams{}

	m.DeleteChatMock = mChatServiceMockDeleteChat{mock: m}
	m.DeleteChatMock.callArgs = []*ChatServiceMockDeleteChatParams{}

	m.GetChatIDByNameMock = mChatServiceMockGetChatIDByName{mock: m}
	m.GetChatIDByNameMock.callArgs = []*ChatServiceMockGetChatIDByNameParams{}

	m.SendMessageMock = mChatServiceMockSendMessage{mock: m}
	m.SendMessageMock.callArgs = []*ChatServiceMockSendMessageParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mChatServiceMockConnectChat struct {
	optional           bool
	mock               *ChatServiceMock
	defaultExpectation *ChatServiceMockConnectChatExpectation
	expectations       []*ChatServiceMockConnectChatExpectation

	callArgs []*ChatServiceMockConnectChatParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ChatServiceMockConnectChatExpectation specifies expectation struct of the ChatService.ConnectChat
type ChatServiceMockConnectChatExpectation struct {
	mock               *ChatServiceMock
	params             *ChatServiceMockConnectChatParams
	paramPtrs          *ChatServiceMockConnectChatParamPtrs
	expectationOrigins ChatServiceMockConnectChatExpectationOrigins
	results            *ChatServiceMockConnectChatResults
	returnOrigin       string
	Counter            uint64
}

// ChatServiceMockConnectChatParams contains parameters of the ChatService.ConnectChat
type ChatServiceMockConnectChatParams struct {
	ctx      context.Context
	chatID   int64
	username string
	stream   chat_v1.ChatV1_ConnectChatServer
}

// ChatServiceMockConnectChatParamPtrs contains pointers to parameters of the ChatService.ConnectChat
type ChatServiceMockConnectChatParamPtrs struct {
	ctx      *context.Context
	chatID   *int64
	username *string
	stream   *chat_v1.ChatV1_ConnectChatServer
}

// ChatServiceMockConnectChatResults contains results of the ChatService.ConnectChat
type ChatServiceMockConnectChatResults struct {
	err error
}

// ChatServiceMockConnectChatOrigins contains origins of expectations of the ChatService.ConnectChat
type ChatServiceMockConnectChatExpectationOrigins struct {
	origin         string
	originCtx      string
	originChatID   string
	originUsername string
	originStream   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmConnectChat *mChatServiceMockConnectChat) Optional() *mChatServiceMockConnectChat {
	mmConnectChat.optional = true
	return mmConnectChat
}

// Expect sets up expected params for ChatService.ConnectChat
func (mmConnectChat *mChatServiceMockConnectChat) Expect(ctx context.Context, chatID int64, username string, stream chat_v1.ChatV1_ConnectChatServer) *mChatServiceMockConnectChat {
	if mmConnectChat.mock.funcConnectChat != nil {
		mmConnectChat.mock.t.Fatalf("ChatServiceMock.ConnectChat mock is already set by Set")
	}

	if mmConnectChat.defaultExpectation == nil {
		mmConnectChat.defaultExpectation = &ChatServiceMockConnectChatExpectation{}
	}

	if mmConnectChat.defaultExpectation.paramPtrs != nil {
		mmConnectChat.mock.t.Fatalf("ChatServiceMock.ConnectChat mock is already set by ExpectParams functions")
	}

	mmConnectChat.defaultExpectation.params = &ChatServiceMockConnectChatParams{ctx, chatID, username, stream}
	mmConnectChat.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmConnectChat.expectations {
		if minimock.Equal(e.params, mmConnectChat.defaultExpectation.params) {
			mmConnectChat.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmConnectChat.defaultExpectation.params)
		}
	}

	return mmConnectChat
}

// ExpectCtxParam1 sets up expected param ctx for ChatService.ConnectChat
func (mmConnectChat *mChatServiceMockConnectChat) ExpectCtxParam1(ctx context.Context) *mChatServiceMockConnectChat {
	if mmConnectChat.mock.funcConnectChat != nil {
		mmConnectChat.mock.t.Fatalf("ChatServiceMock.ConnectChat mock is already set by Set")
	}

	if mmConnectChat.defaultExpectation == nil {
		mmConnectChat.defaultExpectation = &ChatServiceMockConnectChatExpectation{}
	}

	if mmConnectChat.defaultExpectation.params != nil {
		mmConnectChat.mock.t.Fatalf("ChatServiceMock.ConnectChat mock is already set by Expect")
	}

	if mmConnectChat.defaultExpectation.paramPtrs == nil {
		mmConnectChat.defaultExpectation.paramPtrs = &ChatServiceMockConnectChatParamPtrs{}
	}
	mmConnectChat.defaultExpectation.paramPtrs.ctx = &ctx
	mmConnectChat.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmConnectChat
}

// ExpectChatIDParam2 sets up expected param chatID for ChatService.ConnectChat
func (mmConnectChat *mChatServiceMockConnectChat) ExpectChatIDParam2(chatID int64) *mChatServiceMockConnectChat {
	if mmConnectChat.mock.funcConnectChat != nil {
		mmConnectChat.mock.t.Fatalf("ChatServiceMock.ConnectChat mock is already set by Set")
	}

	if mmConnectChat.defaultExpectation == nil {
		mmConnectChat.defaultExpectation = &ChatServiceMockConnectChatExpectation{}
	}

	if mmConnectChat.defaultExpectation.params != nil {
		mmConnectChat.mock.t.Fatalf("ChatServiceMock.ConnectChat mock is already set by Expect")
	}

	if mmConnectChat.defaultExpectation.paramPtrs == nil {
		mmConnectChat.defaultExpectation.paramPtrs = &ChatServiceMockConnectChatParamPtrs{}
	}
	mmConnectChat.defaultExpectation.paramPtrs.chatID = &chatID
	mmConnectChat.defaultExpectation.expectationOrigins.originChatID = minimock.CallerInfo(1)

	return mmConnectChat
}

// ExpectUsernameParam3 sets up expected param username for ChatService.ConnectChat
func (mmConnectChat *mChatServiceMockConnectChat) ExpectUsernameParam3(username string) *mChatServiceMockConnectChat {
	if mmConnectChat.mock.funcConnectChat != nil {
		mmConnectChat.mock.t.Fatalf("ChatServiceMock.ConnectChat mock is already set by Set")
	}

	if mmConnectChat.defaultExpectation == nil {
		mmConnectChat.defaultExpectation = &ChatServiceMockConnectChatExpectation{}
	}

	if mmConnectChat.defaultExpectation.params != nil {
		mmConnectChat.mock.t.Fatalf("ChatServiceMock.ConnectChat mock is already set by Expect")
	}

	if mmConnectChat.defaultExpectation.paramPtrs == nil {
		mmConnectChat.defaultExpectation.paramPtrs = &ChatServiceMockConnectChatParamPtrs{}
	}
	mmConnectChat.defaultExpectation.paramPtrs.username = &username
	mmConnectChat.defaultExpectation.expectationOrigins.originUsername = minimock.CallerInfo(1)

	return mmConnectChat
}

// ExpectStreamParam4 sets up expected param stream for ChatService.ConnectChat
func (mmConnectChat *mChatServiceMockConnectChat) ExpectStreamParam4(stream chat_v1.ChatV1_ConnectChatServer) *mChatServiceMockConnectChat {
	if mmConnectChat.mock.funcConnectChat != nil {
		mmConnectChat.mock.t.Fatalf("ChatServiceMock.ConnectChat mock is already set by Set")
	}

	if mmConnectChat.defaultExpectation == nil {
		mmConnectChat.defaultExpectation = &ChatServiceMockConnectChatExpectation{}
	}

	if mmConnectChat.defaultExpectation.params != nil {
		mmConnectChat.mock.t.Fatalf("ChatServiceMock.ConnectChat mock is already set by Expect")
	}

	if mmConnectChat.defaultExpectation.paramPtrs == nil {
		mmConnectChat.defaultExpectation.paramPtrs = &ChatServiceMockConnectChatParamPtrs{}
	}
	mmConnectChat.defaultExpectation.paramPtrs.stream = &stream
	mmConnectChat.defaultExpectation.expectationOrigins.originStream = minimock.CallerInfo(1)

	return mmConnectChat
}

// Inspect accepts an inspector function that has same arguments as the ChatService.ConnectChat
func (mmConnectChat *mChatServiceMockConnectChat) Inspect(f func(ctx context.Context, chatID int64, username string, stream chat_v1.ChatV1_ConnectChatServer)) *mChatServiceMockConnectChat {
	if mmConnectChat.mock.inspectFuncConnectChat != nil {
		mmConnectChat.mock.t.Fatalf("Inspect function is already set for ChatServiceMock.ConnectChat")
	}

	mmConnectChat.mock.inspectFuncConnectChat = f

	return mmConnectChat
}

// Return sets up results that will be returned by ChatService.ConnectChat
func (mmConnectChat *mChatServiceMockConnectChat) Return(err error) *ChatServiceMock {
	if mmConnectChat.mock.funcConnectChat != nil {
		mmConnectChat.mock.t.Fatalf("ChatServiceMock.ConnectChat mock is already set by Set")
	}

	if mmConnectChat.defaultExpectation == nil {
		mmConnectChat.defaultExpectation = &ChatServiceMockConnectChatExpectation{mock: mmConnectChat.mock}
	}
	mmConnectChat.defaultExpectation.results = &ChatServiceMockConnectChatResults{err}
	mmConnectChat.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmConnectChat.mock
}

// Set uses given function f to mock the ChatService.ConnectChat method
func (mmConnectChat *mChatServiceMockConnectChat) Set(f func(ctx context.Context, chatID int64, username string, stream chat_v1.ChatV1_ConnectChatServer) (err error)) *ChatServiceMock {
	if mmConnectChat.defaultExpectation != nil {
		mmConnectChat.mock.t.Fatalf("Default expectation is already set for the ChatService.ConnectChat method")
	}

	if len(mmConnectChat.expectations) > 0 {
		mmConnectChat.mock.t.Fatalf("Some expectations are already set for the ChatService.ConnectChat method")
	}

	mmConnectChat.mock.funcConnectChat = f
	mmConnectChat.mock.funcConnectChatOrigin = minimock.CallerInfo(1)
	return mmConnectChat.mock
}

// When sets expectation for the ChatService.ConnectChat which will trigger the result defined by the following
// Then helper
func (mmConnectChat *mChatServiceMockConnectChat) When(ctx context.Context, chatID int64, username string, stream chat_v1.ChatV1_ConnectChatServer) *ChatServiceMockConnectChatExpectation {
	if mmConnectChat.mock.funcConnectChat != nil {
		mmConnectChat.mock.t.Fatalf("ChatServiceMock.ConnectChat mock is already set by Set")
	}

	expectation := &ChatServiceMockConnectChatExpectation{
		mock:               mmConnectChat.mock,
		params:             &ChatServiceMockConnectChatParams{ctx, chatID, username, stream},
		expectationOrigins: ChatServiceMockConnectChatExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmConnectChat.expectations = append(mmConnectChat.expectations, expectation)
	return expectation
}

// Then sets up ChatService.ConnectChat return parameters for the expectation previously defined by the When method
func (e *ChatServiceMockConnectChatExpectation) Then(err error) *ChatServiceMock {
	e.results = &ChatServiceMockConnectChatResults{err}
	return e.mock
}

// Times sets number of times ChatService.ConnectChat should be invoked
func (mmConnectChat *mChatServiceMockConnectChat) Times(n uint64) *mChatServiceMockConnectChat {
	if n == 0 {
		mmConnectChat.mock.t.Fatalf("Times of ChatServiceMock.ConnectChat mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmConnectChat.expectedInvocations, n)
	mmConnectChat.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmConnectChat
}

func (mmConnectChat *mChatServiceMockConnectChat) invocationsDone() bool {
	if len(mmConnectChat.expectations) == 0 && mmConnectChat.defaultExpectation == nil && mmConnectChat.mock.funcConnectChat == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmConnectChat.mock.afterConnectChatCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmConnectChat.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ConnectChat implements mm_service.ChatService
func (mmConnectChat *ChatServiceMock) ConnectChat(ctx context.Context, chatID int64, username string, stream chat_v1.ChatV1_ConnectChatServer) (err error) {
	mm_atomic.AddUint64(&mmConnectChat.beforeConnectChatCounter, 1)
	defer mm_atomic.AddUint64(&mmConnectChat.afterConnectChatCounter, 1)

	mmConnectChat.t.Helper()

	if mmConnectChat.inspectFuncConnectChat != nil {
		mmConnectChat.inspectFuncConnectChat(ctx, chatID, username, stream)
	}

	mm_params := ChatServiceMockConnectChatParams{ctx, chatID, username, stream}

	// Record call args
	mmConnectChat.ConnectChatMock.mutex.Lock()
	mmConnectChat.ConnectChatMock.callArgs = append(mmConnectChat.ConnectChatMock.callArgs, &mm_params)
	mmConnectChat.ConnectChatMock.mutex.Unlock()

	for _, e := range mmConnectChat.ConnectChatMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmConnectChat.ConnectChatMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmConnectChat.ConnectChatMock.defaultExpectation.Counter, 1)
		mm_want := mmConnectChat.ConnectChatMock.defaultExpectation.params
		mm_want_ptrs := mmConnectChat.ConnectChatMock.defaultExpectation.paramPtrs

		mm_got := ChatServiceMockConnectChatParams{ctx, chatID, username, stream}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmConnectChat.t.Errorf("ChatServiceMock.ConnectChat got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmConnectChat.ConnectChatMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.chatID != nil && !minimock.Equal(*mm_want_ptrs.chatID, mm_got.chatID) {
				mmConnectChat.t.Errorf("ChatServiceMock.ConnectChat got unexpected parameter chatID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmConnectChat.ConnectChatMock.defaultExpectation.expectationOrigins.originChatID, *mm_want_ptrs.chatID, mm_got.chatID, minimock.Diff(*mm_want_ptrs.chatID, mm_got.chatID))
			}

			if mm_want_ptrs.username != nil && !minimock.Equal(*mm_want_ptrs.username, mm_got.username) {
				mmConnectChat.t.Errorf("ChatServiceMock.ConnectChat got unexpected parameter username, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmConnectChat.ConnectChatMock.defaultExpectation.expectationOrigins.originUsername, *mm_want_ptrs.username, mm_got.username, minimock.Diff(*mm_want_ptrs.username, mm_got.username))
			}

			if mm_want_ptrs.stream != nil && !minimock.Equal(*mm_want_ptrs.stream, mm_got.stream) {
				mmConnectChat.t.Errorf("ChatServiceMock.ConnectChat got unexpected parameter stream, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmConnectChat.ConnectChatMock.defaultExpectation.expectationOrigins.originStream, *mm_want_ptrs.stream, mm_got.stream, minimock.Diff(*mm_want_ptrs.stream, mm_got.stream))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmConnectChat.t.Errorf("ChatServiceMock.ConnectChat got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmConnectChat.ConnectChatMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmConnectChat.ConnectChatMock.defaultExpectation.results
		if mm_results == nil {
			mmConnectChat.t.Fatal("No results are set for the ChatServiceMock.ConnectChat")
		}
		return (*mm_results).err
	}
	if mmConnectChat.funcConnectChat != nil {
		return mmConnectChat.funcConnectChat(ctx, chatID, username, stream)
	}
	mmConnectChat.t.Fatalf("Unexpected call to ChatServiceMock.ConnectChat. %v %v %v %v", ctx, chatID, username, stream)
	return
}

// ConnectChatAfterCounter returns a count of finished ChatServiceMock.ConnectChat invocations
func (mmConnectChat *ChatServiceMock) ConnectChatAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConnectChat.afterConnectChatCounter)
}

// ConnectChatBeforeCounter returns a count of ChatServiceMock.ConnectChat invocations
func (mmConnectChat *ChatServiceMock) ConnectChatBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConnectChat.beforeConnectChatCounter)
}

// Calls returns a list of arguments used in each call to ChatServiceMock.ConnectChat.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmConnectChat *mChatServiceMockConnectChat) Calls() []*ChatServiceMockConnectChatParams {
	mmConnectChat.mutex.RLock()

	argCopy := make([]*ChatServiceMockConnectChatParams, len(mmConnectChat.callArgs))
	copy(argCopy, mmConnectChat.callArgs)

	mmConnectChat.mutex.RUnlock()

	return argCopy
}

// MinimockConnectChatDone returns true if the count of the ConnectChat invocations corresponds
// the number of defined expectations
func (m *ChatServiceMock) MinimockConnectChatDone() bool {
	if m.ConnectChatMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ConnectChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ConnectChatMock.invocationsDone()
}

// MinimockConnectChatInspect logs each unmet expectation
func (m *ChatServiceMock) MinimockConnectChatInspect() {
	for _, e := range m.ConnectChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServiceMock.ConnectChat at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterConnectChatCounter := mm_atomic.LoadUint64(&m.afterConnectChatCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ConnectChatMock.defaultExpectation != nil && afterConnectChatCounter < 1 {
		if m.ConnectChatMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ChatServiceMock.ConnectChat at\n%s", m.ConnectChatMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ChatServiceMock.ConnectChat at\n%s with params: %#v", m.ConnectChatMock.defaultExpectation.expectationOrigins.origin, *m.ConnectChatMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcConnectChat != nil && afterConnectChatCounter < 1 {
		m.t.Errorf("Expected call to ChatServiceMock.ConnectChat at\n%s", m.funcConnectChatOrigin)
	}

	if !m.ConnectChatMock.invocationsDone() && afterConnectChatCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatServiceMock.ConnectChat at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ConnectChatMock.expectedInvocations), m.ConnectChatMock.expectedInvocationsOrigin, afterConnectChatCounter)
	}
}

type mChatServiceMockCreateChat struct {
	optional           bool
	mock               *ChatServiceMock
	defaultExpectation *ChatServiceMockCreateChatExpectation
	expectations       []*ChatServiceMockCreateChatExpectation

	callArgs []*ChatServiceMockCreateChatParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ChatServiceMockCreateChatExpectation specifies expectation struct of the ChatService.CreateChat
type ChatServiceMockCreateChatExpectation struct {
	mock               *ChatServiceMock
	params             *ChatServiceMockCreateChatParams
	paramPtrs          *ChatServiceMockCreateChatParamPtrs
	expectationOrigins ChatServiceMockCreateChatExpectationOrigins
	results            *ChatServiceMockCreateChatResults
	returnOrigin       string
	Counter            uint64
}

// ChatServiceMockCreateChatParams contains parameters of the ChatService.CreateChat
type ChatServiceMockCreateChatParams struct {
	ctx context.Context
	req *chat_v1.CreateChatRequest
}

// ChatServiceMockCreateChatParamPtrs contains pointers to parameters of the ChatService.CreateChat
type ChatServiceMockCreateChatParamPtrs struct {
	ctx *context.Context
	req **chat_v1.CreateChatRequest
}

// ChatServiceMockCreateChatResults contains results of the ChatService.CreateChat
type ChatServiceMockCreateChatResults struct {
	i1  int64
	err error
}

// ChatServiceMockCreateChatOrigins contains origins of expectations of the ChatService.CreateChat
type ChatServiceMockCreateChatExpectationOrigins struct {
	origin    string
	originCtx string
	originReq string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateChat *mChatServiceMockCreateChat) Optional() *mChatServiceMockCreateChat {
	mmCreateChat.optional = true
	return mmCreateChat
}

// Expect sets up expected params for ChatService.CreateChat
func (mmCreateChat *mChatServiceMockCreateChat) Expect(ctx context.Context, req *chat_v1.CreateChatRequest) *mChatServiceMockCreateChat {
	if mmCreateChat.mock.funcCreateChat != nil {
		mmCreateChat.mock.t.Fatalf("ChatServiceMock.CreateChat mock is already set by Set")
	}

	if mmCreateChat.defaultExpectation == nil {
		mmCreateChat.defaultExpectation = &ChatServiceMockCreateChatExpectation{}
	}

	if mmCreateChat.defaultExpectation.paramPtrs != nil {
		mmCreateChat.mock.t.Fatalf("ChatServiceMock.CreateChat mock is already set by ExpectParams functions")
	}

	mmCreateChat.defaultExpectation.params = &ChatServiceMockCreateChatParams{ctx, req}
	mmCreateChat.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateChat.expectations {
		if minimock.Equal(e.params, mmCreateChat.defaultExpectation.params) {
			mmCreateChat.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateChat.defaultExpectation.params)
		}
	}

	return mmCreateChat
}

// ExpectCtxParam1 sets up expected param ctx for ChatService.CreateChat
func (mmCreateChat *mChatServiceMockCreateChat) ExpectCtxParam1(ctx context.Context) *mChatServiceMockCreateChat {
	if mmCreateChat.mock.funcCreateChat != nil {
		mmCreateChat.mock.t.Fatalf("ChatServiceMock.CreateChat mock is already set by Set")
	}

	if mmCreateChat.defaultExpectation == nil {
		mmCreateChat.defaultExpectation = &ChatServiceMockCreateChatExpectation{}
	}

	if mmCreateChat.defaultExpectation.params != nil {
		mmCreateChat.mock.t.Fatalf("ChatServiceMock.CreateChat mock is already set by Expect")
	}

	if mmCreateChat.defaultExpectation.paramPtrs == nil {
		mmCreateChat.defaultExpectation.paramPtrs = &ChatServiceMockCreateChatParamPtrs{}
	}
	mmCreateChat.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateChat.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateChat
}

// ExpectReqParam2 sets up expected param req for ChatService.CreateChat
func (mmCreateChat *mChatServiceMockCreateChat) ExpectReqParam2(req *chat_v1.CreateChatRequest) *mChatServiceMockCreateChat {
	if mmCreateChat.mock.funcCreateChat != nil {
		mmCreateChat.mock.t.Fatalf("ChatServiceMock.CreateChat mock is already set by Set")
	}

	if mmCreateChat.defaultExpectation == nil {
		mmCreateChat.defaultExpectation = &ChatServiceMockCreateChatExpectation{}
	}

	if mmCreateChat.defaultExpectation.params != nil {
		mmCreateChat.mock.t.Fatalf("ChatServiceMock.CreateChat mock is already set by Expect")
	}

	if mmCreateChat.defaultExpectation.paramPtrs == nil {
		mmCreateChat.defaultExpectation.paramPtrs = &ChatServiceMockCreateChatParamPtrs{}
	}
	mmCreateChat.defaultExpectation.paramPtrs.req = &req
	mmCreateChat.defaultExpectation.expectationOrigins.originReq = minimock.CallerInfo(1)

	return mmCreateChat
}

// Inspect accepts an inspector function that has same arguments as the ChatService.CreateChat
func (mmCreateChat *mChatServiceMockCreateChat) Inspect(f func(ctx context.Context, req *chat_v1.CreateChatRequest)) *mChatServiceMockCreateChat {
	if mmCreateChat.mock.inspectFuncCreateChat != nil {
		mmCreateChat.mock.t.Fatalf("Inspect function is already set for ChatServiceMock.CreateChat")
	}

	mmCreateChat.mock.inspectFuncCreateChat = f

	return mmCreateChat
}

// Return sets up results that will be returned by ChatService.CreateChat
func (mmCreateChat *mChatServiceMockCreateChat) Return(i1 int64, err error) *ChatServiceMock {
	if mmCreateChat.mock.funcCreateChat != nil {
		mmCreateChat.mock.t.Fatalf("ChatServiceMock.CreateChat mock is already set by Set")
	}

	if mmCreateChat.defaultExpectation == nil {
		mmCreateChat.defaultExpectation = &ChatServiceMockCreateChatExpectation{mock: mmCreateChat.mock}
	}
	mmCreateChat.defaultExpectation.results = &ChatServiceMockCreateChatResults{i1, err}
	mmCreateChat.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateChat.mock
}

// Set uses given function f to mock the ChatService.CreateChat method
func (mmCreateChat *mChatServiceMockCreateChat) Set(f func(ctx context.Context, req *chat_v1.CreateChatRequest) (i1 int64, err error)) *ChatServiceMock {
	if mmCreateChat.defaultExpectation != nil {
		mmCreateChat.mock.t.Fatalf("Default expectation is already set for the ChatService.CreateChat method")
	}

	if len(mmCreateChat.expectations) > 0 {
		mmCreateChat.mock.t.Fatalf("Some expectations are already set for the ChatService.CreateChat method")
	}

	mmCreateChat.mock.funcCreateChat = f
	mmCreateChat.mock.funcCreateChatOrigin = minimock.CallerInfo(1)
	return mmCreateChat.mock
}

// When sets expectation for the ChatService.CreateChat which will trigger the result defined by the following
// Then helper
func (mmCreateChat *mChatServiceMockCreateChat) When(ctx context.Context, req *chat_v1.CreateChatRequest) *ChatServiceMockCreateChatExpectation {
	if mmCreateChat.mock.funcCreateChat != nil {
		mmCreateChat.mock.t.Fatalf("ChatServiceMock.CreateChat mock is already set by Set")
	}

	expectation := &ChatServiceMockCreateChatExpectation{
		mock:               mmCreateChat.mock,
		params:             &ChatServiceMockCreateChatParams{ctx, req},
		expectationOrigins: ChatServiceMockCreateChatExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateChat.expectations = append(mmCreateChat.expectations, expectation)
	return expectation
}

// Then sets up ChatService.CreateChat return parameters for the expectation previously defined by the When method
func (e *ChatServiceMockCreateChatExpectation) Then(i1 int64, err error) *ChatServiceMock {
	e.results = &ChatServiceMockCreateChatResults{i1, err}
	return e.mock
}

// Times sets number of times ChatService.CreateChat should be invoked
func (mmCreateChat *mChatServiceMockCreateChat) Times(n uint64) *mChatServiceMockCreateChat {
	if n == 0 {
		mmCreateChat.mock.t.Fatalf("Times of ChatServiceMock.CreateChat mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateChat.expectedInvocations, n)
	mmCreateChat.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateChat
}

func (mmCreateChat *mChatServiceMockCreateChat) invocationsDone() bool {
	if len(mmCreateChat.expectations) == 0 && mmCreateChat.defaultExpectation == nil && mmCreateChat.mock.funcCreateChat == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateChat.mock.afterCreateChatCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateChat.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateChat implements mm_service.ChatService
func (mmCreateChat *ChatServiceMock) CreateChat(ctx context.Context, req *chat_v1.CreateChatRequest) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmCreateChat.beforeCreateChatCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateChat.afterCreateChatCounter, 1)

	mmCreateChat.t.Helper()

	if mmCreateChat.inspectFuncCreateChat != nil {
		mmCreateChat.inspectFuncCreateChat(ctx, req)
	}

	mm_params := ChatServiceMockCreateChatParams{ctx, req}

	// Record call args
	mmCreateChat.CreateChatMock.mutex.Lock()
	mmCreateChat.CreateChatMock.callArgs = append(mmCreateChat.CreateChatMock.callArgs, &mm_params)
	mmCreateChat.CreateChatMock.mutex.Unlock()

	for _, e := range mmCreateChat.CreateChatMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCreateChat.CreateChatMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateChat.CreateChatMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateChat.CreateChatMock.defaultExpectation.params
		mm_want_ptrs := mmCreateChat.CreateChatMock.defaultExpectation.paramPtrs

		mm_got := ChatServiceMockCreateChatParams{ctx, req}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateChat.t.Errorf("ChatServiceMock.CreateChat got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateChat.CreateChatMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.req != nil && !minimock.Equal(*mm_want_ptrs.req, mm_got.req) {
				mmCreateChat.t.Errorf("ChatServiceMock.CreateChat got unexpected parameter req, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateChat.CreateChatMock.defaultExpectation.expectationOrigins.originReq, *mm_want_ptrs.req, mm_got.req, minimock.Diff(*mm_want_ptrs.req, mm_got.req))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateChat.t.Errorf("ChatServiceMock.CreateChat got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateChat.CreateChatMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateChat.CreateChatMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateChat.t.Fatal("No results are set for the ChatServiceMock.CreateChat")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCreateChat.funcCreateChat != nil {
		return mmCreateChat.funcCreateChat(ctx, req)
	}
	mmCreateChat.t.Fatalf("Unexpected call to ChatServiceMock.CreateChat. %v %v", ctx, req)
	return
}

// CreateChatAfterCounter returns a count of finished ChatServiceMock.CreateChat invocations
func (mmCreateChat *ChatServiceMock) CreateChatAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateChat.afterCreateChatCounter)
}

// CreateChatBeforeCounter returns a count of ChatServiceMock.CreateChat invocations
func (mmCreateChat *ChatServiceMock) CreateChatBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateChat.beforeCreateChatCounter)
}

// Calls returns a list of arguments used in each call to ChatServiceMock.CreateChat.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateChat *mChatServiceMockCreateChat) Calls() []*ChatServiceMockCreateChatParams {
	mmCreateChat.mutex.RLock()

	argCopy := make([]*ChatServiceMockCreateChatParams, len(mmCreateChat.callArgs))
	copy(argCopy, mmCreateChat.callArgs)

	mmCreateChat.mutex.RUnlock()

	return argCopy
}

// MinimockCreateChatDone returns true if the count of the CreateChat invocations corresponds
// the number of defined expectations
func (m *ChatServiceMock) MinimockCreateChatDone() bool {
	if m.CreateChatMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateChatMock.invocationsDone()
}

// MinimockCreateChatInspect logs each unmet expectation
func (m *ChatServiceMock) MinimockCreateChatInspect() {
	for _, e := range m.CreateChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServiceMock.CreateChat at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateChatCounter := mm_atomic.LoadUint64(&m.afterCreateChatCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateChatMock.defaultExpectation != nil && afterCreateChatCounter < 1 {
		if m.CreateChatMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ChatServiceMock.CreateChat at\n%s", m.CreateChatMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ChatServiceMock.CreateChat at\n%s with params: %#v", m.CreateChatMock.defaultExpectation.expectationOrigins.origin, *m.CreateChatMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateChat != nil && afterCreateChatCounter < 1 {
		m.t.Errorf("Expected call to ChatServiceMock.CreateChat at\n%s", m.funcCreateChatOrigin)
	}

	if !m.CreateChatMock.invocationsDone() && afterCreateChatCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatServiceMock.CreateChat at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateChatMock.expectedInvocations), m.CreateChatMock.expectedInvocationsOrigin, afterCreateChatCounter)
	}
}

type mChatServiceMockDeleteChat struct {
	optional           bool
	mock               *ChatServiceMock
	defaultExpectation *ChatServiceMockDeleteChatExpectation
	expectations       []*ChatServiceMockDeleteChatExpectation

	callArgs []*ChatServiceMockDeleteChatParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ChatServiceMockDeleteChatExpectation specifies expectation struct of the ChatService.DeleteChat
type ChatServiceMockDeleteChatExpectation struct {
	mock               *ChatServiceMock
	params             *ChatServiceMockDeleteChatParams
	paramPtrs          *ChatServiceMockDeleteChatParamPtrs
	expectationOrigins ChatServiceMockDeleteChatExpectationOrigins
	results            *ChatServiceMockDeleteChatResults
	returnOrigin       string
	Counter            uint64
}

// ChatServiceMockDeleteChatParams contains parameters of the ChatService.DeleteChat
type ChatServiceMockDeleteChatParams struct {
	ctx context.Context
	id  int64
}

// ChatServiceMockDeleteChatParamPtrs contains pointers to parameters of the ChatService.DeleteChat
type ChatServiceMockDeleteChatParamPtrs struct {
	ctx *context.Context
	id  *int64
}

// ChatServiceMockDeleteChatResults contains results of the ChatService.DeleteChat
type ChatServiceMockDeleteChatResults struct {
	err error
}

// ChatServiceMockDeleteChatOrigins contains origins of expectations of the ChatService.DeleteChat
type ChatServiceMockDeleteChatExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteChat *mChatServiceMockDeleteChat) Optional() *mChatServiceMockDeleteChat {
	mmDeleteChat.optional = true
	return mmDeleteChat
}

// Expect sets up expected params for ChatService.DeleteChat
func (mmDeleteChat *mChatServiceMockDeleteChat) Expect(ctx context.Context, id int64) *mChatServiceMockDeleteChat {
	if mmDeleteChat.mock.funcDeleteChat != nil {
		mmDeleteChat.mock.t.Fatalf("ChatServiceMock.DeleteChat mock is already set by Set")
	}

	if mmDeleteChat.defaultExpectation == nil {
		mmDeleteChat.defaultExpectation = &ChatServiceMockDeleteChatExpectation{}
	}

	if mmDeleteChat.defaultExpectation.paramPtrs != nil {
		mmDeleteChat.mock.t.Fatalf("ChatServiceMock.DeleteChat mock is already set by ExpectParams functions")
	}

	mmDeleteChat.defaultExpectation.params = &ChatServiceMockDeleteChatParams{ctx, id}
	mmDeleteChat.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteChat.expectations {
		if minimock.Equal(e.params, mmDeleteChat.defaultExpectation.params) {
			mmDeleteChat.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteChat.defaultExpectation.params)
		}
	}

	return mmDeleteChat
}

// ExpectCtxParam1 sets up expected param ctx for ChatService.DeleteChat
func (mmDeleteChat *mChatServiceMockDeleteChat) ExpectCtxParam1(ctx context.Context) *mChatServiceMockDeleteChat {
	if mmDeleteChat.mock.funcDeleteChat != nil {
		mmDeleteChat.mock.t.Fatalf("ChatServiceMock.DeleteChat mock is already set by Set")
	}

	if mmDeleteChat.defaultExpectation == nil {
		mmDeleteChat.defaultExpectation = &ChatServiceMockDeleteChatExpectation{}
	}

	if mmDeleteChat.defaultExpectation.params != nil {
		mmDeleteChat.mock.t.Fatalf("ChatServiceMock.DeleteChat mock is already set by Expect")
	}

	if mmDeleteChat.defaultExpectation.paramPtrs == nil {
		mmDeleteChat.defaultExpectation.paramPtrs = &ChatServiceMockDeleteChatParamPtrs{}
	}
	mmDeleteChat.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteChat.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteChat
}

// ExpectIdParam2 sets up expected param id for ChatService.DeleteChat
func (mmDeleteChat *mChatServiceMockDeleteChat) ExpectIdParam2(id int64) *mChatServiceMockDeleteChat {
	if mmDeleteChat.mock.funcDeleteChat != nil {
		mmDeleteChat.mock.t.Fatalf("ChatServiceMock.DeleteChat mock is already set by Set")
	}

	if mmDeleteChat.defaultExpectation == nil {
		mmDeleteChat.defaultExpectation = &ChatServiceMockDeleteChatExpectation{}
	}

	if mmDeleteChat.defaultExpectation.params != nil {
		mmDeleteChat.mock.t.Fatalf("ChatServiceMock.DeleteChat mock is already set by Expect")
	}

	if mmDeleteChat.defaultExpectation.paramPtrs == nil {
		mmDeleteChat.defaultExpectation.paramPtrs = &ChatServiceMockDeleteChatParamPtrs{}
	}
	mmDeleteChat.defaultExpectation.paramPtrs.id = &id
	mmDeleteChat.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmDeleteChat
}

// Inspect accepts an inspector function that has same arguments as the ChatService.DeleteChat
func (mmDeleteChat *mChatServiceMockDeleteChat) Inspect(f func(ctx context.Context, id int64)) *mChatServiceMockDeleteChat {
	if mmDeleteChat.mock.inspectFuncDeleteChat != nil {
		mmDeleteChat.mock.t.Fatalf("Inspect function is already set for ChatServiceMock.DeleteChat")
	}

	mmDeleteChat.mock.inspectFuncDeleteChat = f

	return mmDeleteChat
}

// Return sets up results that will be returned by ChatService.DeleteChat
func (mmDeleteChat *mChatServiceMockDeleteChat) Return(err error) *ChatServiceMock {
	if mmDeleteChat.mock.funcDeleteChat != nil {
		mmDeleteChat.mock.t.Fatalf("ChatServiceMock.DeleteChat mock is already set by Set")
	}

	if mmDeleteChat.defaultExpectation == nil {
		mmDeleteChat.defaultExpectation = &ChatServiceMockDeleteChatExpectation{mock: mmDeleteChat.mock}
	}
	mmDeleteChat.defaultExpectation.results = &ChatServiceMockDeleteChatResults{err}
	mmDeleteChat.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteChat.mock
}

// Set uses given function f to mock the ChatService.DeleteChat method
func (mmDeleteChat *mChatServiceMockDeleteChat) Set(f func(ctx context.Context, id int64) (err error)) *ChatServiceMock {
	if mmDeleteChat.defaultExpectation != nil {
		mmDeleteChat.mock.t.Fatalf("Default expectation is already set for the ChatService.DeleteChat method")
	}

	if len(mmDeleteChat.expectations) > 0 {
		mmDeleteChat.mock.t.Fatalf("Some expectations are already set for the ChatService.DeleteChat method")
	}

	mmDeleteChat.mock.funcDeleteChat = f
	mmDeleteChat.mock.funcDeleteChatOrigin = minimock.CallerInfo(1)
	return mmDeleteChat.mock
}

// When sets expectation for the ChatService.DeleteChat which will trigger the result defined by the following
// Then helper
func (mmDeleteChat *mChatServiceMockDeleteChat) When(ctx context.Context, id int64) *ChatServiceMockDeleteChatExpectation {
	if mmDeleteChat.mock.funcDeleteChat != nil {
		mmDeleteChat.mock.t.Fatalf("ChatServiceMock.DeleteChat mock is already set by Set")
	}

	expectation := &ChatServiceMockDeleteChatExpectation{
		mock:               mmDeleteChat.mock,
		params:             &ChatServiceMockDeleteChatParams{ctx, id},
		expectationOrigins: ChatServiceMockDeleteChatExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteChat.expectations = append(mmDeleteChat.expectations, expectation)
	return expectation
}

// Then sets up ChatService.DeleteChat return parameters for the expectation previously defined by the When method
func (e *ChatServiceMockDeleteChatExpectation) Then(err error) *ChatServiceMock {
	e.results = &ChatServiceMockDeleteChatResults{err}
	return e.mock
}

// Times sets number of times ChatService.DeleteChat should be invoked
func (mmDeleteChat *mChatServiceMockDeleteChat) Times(n uint64) *mChatServiceMockDeleteChat {
	if n == 0 {
		mmDeleteChat.mock.t.Fatalf("Times of ChatServiceMock.DeleteChat mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteChat.expectedInvocations, n)
	mmDeleteChat.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteChat
}

func (mmDeleteChat *mChatServiceMockDeleteChat) invocationsDone() bool {
	if len(mmDeleteChat.expectations) == 0 && mmDeleteChat.defaultExpectation == nil && mmDeleteChat.mock.funcDeleteChat == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteChat.mock.afterDeleteChatCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteChat.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteChat implements mm_service.ChatService
func (mmDeleteChat *ChatServiceMock) DeleteChat(ctx context.Context, id int64) (err error) {
	mm_atomic.AddUint64(&mmDeleteChat.beforeDeleteChatCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteChat.afterDeleteChatCounter, 1)

	mmDeleteChat.t.Helper()

	if mmDeleteChat.inspectFuncDeleteChat != nil {
		mmDeleteChat.inspectFuncDeleteChat(ctx, id)
	}

	mm_params := ChatServiceMockDeleteChatParams{ctx, id}

	// Record call args
	mmDeleteChat.DeleteChatMock.mutex.Lock()
	mmDeleteChat.DeleteChatMock.callArgs = append(mmDeleteChat.DeleteChatMock.callArgs, &mm_params)
	mmDeleteChat.DeleteChatMock.mutex.Unlock()

	for _, e := range mmDeleteChat.DeleteChatMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteChat.DeleteChatMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteChat.DeleteChatMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteChat.DeleteChatMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteChat.DeleteChatMock.defaultExpectation.paramPtrs

		mm_got := ChatServiceMockDeleteChatParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteChat.t.Errorf("ChatServiceMock.DeleteChat got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteChat.DeleteChatMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmDeleteChat.t.Errorf("ChatServiceMock.DeleteChat got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteChat.DeleteChatMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteChat.t.Errorf("ChatServiceMock.DeleteChat got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteChat.DeleteChatMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteChat.DeleteChatMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteChat.t.Fatal("No results are set for the ChatServiceMock.DeleteChat")
		}
		return (*mm_results).err
	}
	if mmDeleteChat.funcDeleteChat != nil {
		return mmDeleteChat.funcDeleteChat(ctx, id)
	}
	mmDeleteChat.t.Fatalf("Unexpected call to ChatServiceMock.DeleteChat. %v %v", ctx, id)
	return
}

// DeleteChatAfterCounter returns a count of finished ChatServiceMock.DeleteChat invocations
func (mmDeleteChat *ChatServiceMock) DeleteChatAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteChat.afterDeleteChatCounter)
}

// DeleteChatBeforeCounter returns a count of ChatServiceMock.DeleteChat invocations
func (mmDeleteChat *ChatServiceMock) DeleteChatBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteChat.beforeDeleteChatCounter)
}

// Calls returns a list of arguments used in each call to ChatServiceMock.DeleteChat.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteChat *mChatServiceMockDeleteChat) Calls() []*ChatServiceMockDeleteChatParams {
	mmDeleteChat.mutex.RLock()

	argCopy := make([]*ChatServiceMockDeleteChatParams, len(mmDeleteChat.callArgs))
	copy(argCopy, mmDeleteChat.callArgs)

	mmDeleteChat.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteChatDone returns true if the count of the DeleteChat invocations corresponds
// the number of defined expectations
func (m *ChatServiceMock) MinimockDeleteChatDone() bool {
	if m.DeleteChatMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteChatMock.invocationsDone()
}

// MinimockDeleteChatInspect logs each unmet expectation
func (m *ChatServiceMock) MinimockDeleteChatInspect() {
	for _, e := range m.DeleteChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServiceMock.DeleteChat at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteChatCounter := mm_atomic.LoadUint64(&m.afterDeleteChatCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteChatMock.defaultExpectation != nil && afterDeleteChatCounter < 1 {
		if m.DeleteChatMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ChatServiceMock.DeleteChat at\n%s", m.DeleteChatMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ChatServiceMock.DeleteChat at\n%s with params: %#v", m.DeleteChatMock.defaultExpectation.expectationOrigins.origin, *m.DeleteChatMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteChat != nil && afterDeleteChatCounter < 1 {
		m.t.Errorf("Expected call to ChatServiceMock.DeleteChat at\n%s", m.funcDeleteChatOrigin)
	}

	if !m.DeleteChatMock.invocationsDone() && afterDeleteChatCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatServiceMock.DeleteChat at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteChatMock.expectedInvocations), m.DeleteChatMock.expectedInvocationsOrigin, afterDeleteChatCounter)
	}
}

type mChatServiceMockGetChatIDByName struct {
	optional           bool
	mock               *ChatServiceMock
	defaultExpectation *ChatServiceMockGetChatIDByNameExpectation
	expectations       []*ChatServiceMockGetChatIDByNameExpectation

	callArgs []*ChatServiceMockGetChatIDByNameParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ChatServiceMockGetChatIDByNameExpectation specifies expectation struct of the ChatService.GetChatIDByName
type ChatServiceMockGetChatIDByNameExpectation struct {
	mock               *ChatServiceMock
	params             *ChatServiceMockGetChatIDByNameParams
	paramPtrs          *ChatServiceMockGetChatIDByNameParamPtrs
	expectationOrigins ChatServiceMockGetChatIDByNameExpectationOrigins
	results            *ChatServiceMockGetChatIDByNameResults
	returnOrigin       string
	Counter            uint64
}

// ChatServiceMockGetChatIDByNameParams contains parameters of the ChatService.GetChatIDByName
type ChatServiceMockGetChatIDByNameParams struct {
	ctx      context.Context
	chatname string
}

// ChatServiceMockGetChatIDByNameParamPtrs contains pointers to parameters of the ChatService.GetChatIDByName
type ChatServiceMockGetChatIDByNameParamPtrs struct {
	ctx      *context.Context
	chatname *string
}

// ChatServiceMockGetChatIDByNameResults contains results of the ChatService.GetChatIDByName
type ChatServiceMockGetChatIDByNameResults struct {
	i1  int64
	err error
}

// ChatServiceMockGetChatIDByNameOrigins contains origins of expectations of the ChatService.GetChatIDByName
type ChatServiceMockGetChatIDByNameExpectationOrigins struct {
	origin         string
	originCtx      string
	originChatname string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetChatIDByName *mChatServiceMockGetChatIDByName) Optional() *mChatServiceMockGetChatIDByName {
	mmGetChatIDByName.optional = true
	return mmGetChatIDByName
}

// Expect sets up expected params for ChatService.GetChatIDByName
func (mmGetChatIDByName *mChatServiceMockGetChatIDByName) Expect(ctx context.Context, chatname string) *mChatServiceMockGetChatIDByName {
	if mmGetChatIDByName.mock.funcGetChatIDByName != nil {
		mmGetChatIDByName.mock.t.Fatalf("ChatServiceMock.GetChatIDByName mock is already set by Set")
	}

	if mmGetChatIDByName.defaultExpectation == nil {
		mmGetChatIDByName.defaultExpectation = &ChatServiceMockGetChatIDByNameExpectation{}
	}

	if mmGetChatIDByName.defaultExpectation.paramPtrs != nil {
		mmGetChatIDByName.mock.t.Fatalf("ChatServiceMock.GetChatIDByName mock is already set by ExpectParams functions")
	}

	mmGetChatIDByName.defaultExpectation.params = &ChatServiceMockGetChatIDByNameParams{ctx, chatname}
	mmGetChatIDByName.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetChatIDByName.expectations {
		if minimock.Equal(e.params, mmGetChatIDByName.defaultExpectation.params) {
			mmGetChatIDByName.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetChatIDByName.defaultExpectation.params)
		}
	}

	return mmGetChatIDByName
}

// ExpectCtxParam1 sets up expected param ctx for ChatService.GetChatIDByName
func (mmGetChatIDByName *mChatServiceMockGetChatIDByName) ExpectCtxParam1(ctx context.Context) *mChatServiceMockGetChatIDByName {
	if mmGetChatIDByName.mock.funcGetChatIDByName != nil {
		mmGetChatIDByName.mock.t.Fatalf("ChatServiceMock.GetChatIDByName mock is already set by Set")
	}

	if mmGetChatIDByName.defaultExpectation == nil {
		mmGetChatIDByName.defaultExpectation = &ChatServiceMockGetChatIDByNameExpectation{}
	}

	if mmGetChatIDByName.defaultExpectation.params != nil {
		mmGetChatIDByName.mock.t.Fatalf("ChatServiceMock.GetChatIDByName mock is already set by Expect")
	}

	if mmGetChatIDByName.defaultExpectation.paramPtrs == nil {
		mmGetChatIDByName.defaultExpectation.paramPtrs = &ChatServiceMockGetChatIDByNameParamPtrs{}
	}
	mmGetChatIDByName.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetChatIDByName.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetChatIDByName
}

// ExpectChatnameParam2 sets up expected param chatname for ChatService.GetChatIDByName
func (mmGetChatIDByName *mChatServiceMockGetChatIDByName) ExpectChatnameParam2(chatname string) *mChatServiceMockGetChatIDByName {
	if mmGetChatIDByName.mock.funcGetChatIDByName != nil {
		mmGetChatIDByName.mock.t.Fatalf("ChatServiceMock.GetChatIDByName mock is already set by Set")
	}

	if mmGetChatIDByName.defaultExpectation == nil {
		mmGetChatIDByName.defaultExpectation = &ChatServiceMockGetChatIDByNameExpectation{}
	}

	if mmGetChatIDByName.defaultExpectation.params != nil {
		mmGetChatIDByName.mock.t.Fatalf("ChatServiceMock.GetChatIDByName mock is already set by Expect")
	}

	if mmGetChatIDByName.defaultExpectation.paramPtrs == nil {
		mmGetChatIDByName.defaultExpectation.paramPtrs = &ChatServiceMockGetChatIDByNameParamPtrs{}
	}
	mmGetChatIDByName.defaultExpectation.paramPtrs.chatname = &chatname
	mmGetChatIDByName.defaultExpectation.expectationOrigins.originChatname = minimock.CallerInfo(1)

	return mmGetChatIDByName
}

// Inspect accepts an inspector function that has same arguments as the ChatService.GetChatIDByName
func (mmGetChatIDByName *mChatServiceMockGetChatIDByName) Inspect(f func(ctx context.Context, chatname string)) *mChatServiceMockGetChatIDByName {
	if mmGetChatIDByName.mock.inspectFuncGetChatIDByName != nil {
		mmGetChatIDByName.mock.t.Fatalf("Inspect function is already set for ChatServiceMock.GetChatIDByName")
	}

	mmGetChatIDByName.mock.inspectFuncGetChatIDByName = f

	return mmGetChatIDByName
}

// Return sets up results that will be returned by ChatService.GetChatIDByName
func (mmGetChatIDByName *mChatServiceMockGetChatIDByName) Return(i1 int64, err error) *ChatServiceMock {
	if mmGetChatIDByName.mock.funcGetChatIDByName != nil {
		mmGetChatIDByName.mock.t.Fatalf("ChatServiceMock.GetChatIDByName mock is already set by Set")
	}

	if mmGetChatIDByName.defaultExpectation == nil {
		mmGetChatIDByName.defaultExpectation = &ChatServiceMockGetChatIDByNameExpectation{mock: mmGetChatIDByName.mock}
	}
	mmGetChatIDByName.defaultExpectation.results = &ChatServiceMockGetChatIDByNameResults{i1, err}
	mmGetChatIDByName.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetChatIDByName.mock
}

// Set uses given function f to mock the ChatService.GetChatIDByName method
func (mmGetChatIDByName *mChatServiceMockGetChatIDByName) Set(f func(ctx context.Context, chatname string) (i1 int64, err error)) *ChatServiceMock {
	if mmGetChatIDByName.defaultExpectation != nil {
		mmGetChatIDByName.mock.t.Fatalf("Default expectation is already set for the ChatService.GetChatIDByName method")
	}

	if len(mmGetChatIDByName.expectations) > 0 {
		mmGetChatIDByName.mock.t.Fatalf("Some expectations are already set for the ChatService.GetChatIDByName method")
	}

	mmGetChatIDByName.mock.funcGetChatIDByName = f
	mmGetChatIDByName.mock.funcGetChatIDByNameOrigin = minimock.CallerInfo(1)
	return mmGetChatIDByName.mock
}

// When sets expectation for the ChatService.GetChatIDByName which will trigger the result defined by the following
// Then helper
func (mmGetChatIDByName *mChatServiceMockGetChatIDByName) When(ctx context.Context, chatname string) *ChatServiceMockGetChatIDByNameExpectation {
	if mmGetChatIDByName.mock.funcGetChatIDByName != nil {
		mmGetChatIDByName.mock.t.Fatalf("ChatServiceMock.GetChatIDByName mock is already set by Set")
	}

	expectation := &ChatServiceMockGetChatIDByNameExpectation{
		mock:               mmGetChatIDByName.mock,
		params:             &ChatServiceMockGetChatIDByNameParams{ctx, chatname},
		expectationOrigins: ChatServiceMockGetChatIDByNameExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetChatIDByName.expectations = append(mmGetChatIDByName.expectations, expectation)
	return expectation
}

// Then sets up ChatService.GetChatIDByName return parameters for the expectation previously defined by the When method
func (e *ChatServiceMockGetChatIDByNameExpectation) Then(i1 int64, err error) *ChatServiceMock {
	e.results = &ChatServiceMockGetChatIDByNameResults{i1, err}
	return e.mock
}

// Times sets number of times ChatService.GetChatIDByName should be invoked
func (mmGetChatIDByName *mChatServiceMockGetChatIDByName) Times(n uint64) *mChatServiceMockGetChatIDByName {
	if n == 0 {
		mmGetChatIDByName.mock.t.Fatalf("Times of ChatServiceMock.GetChatIDByName mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetChatIDByName.expectedInvocations, n)
	mmGetChatIDByName.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetChatIDByName
}

func (mmGetChatIDByName *mChatServiceMockGetChatIDByName) invocationsDone() bool {
	if len(mmGetChatIDByName.expectations) == 0 && mmGetChatIDByName.defaultExpectation == nil && mmGetChatIDByName.mock.funcGetChatIDByName == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetChatIDByName.mock.afterGetChatIDByNameCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetChatIDByName.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetChatIDByName implements mm_service.ChatService
func (mmGetChatIDByName *ChatServiceMock) GetChatIDByName(ctx context.Context, chatname string) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmGetChatIDByName.beforeGetChatIDByNameCounter, 1)
	defer mm_atomic.AddUint64(&mmGetChatIDByName.afterGetChatIDByNameCounter, 1)

	mmGetChatIDByName.t.Helper()

	if mmGetChatIDByName.inspectFuncGetChatIDByName != nil {
		mmGetChatIDByName.inspectFuncGetChatIDByName(ctx, chatname)
	}

	mm_params := ChatServiceMockGetChatIDByNameParams{ctx, chatname}

	// Record call args
	mmGetChatIDByName.GetChatIDByNameMock.mutex.Lock()
	mmGetChatIDByName.GetChatIDByNameMock.callArgs = append(mmGetChatIDByName.GetChatIDByNameMock.callArgs, &mm_params)
	mmGetChatIDByName.GetChatIDByNameMock.mutex.Unlock()

	for _, e := range mmGetChatIDByName.GetChatIDByNameMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmGetChatIDByName.GetChatIDByNameMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetChatIDByName.GetChatIDByNameMock.defaultExpectation.Counter, 1)
		mm_want := mmGetChatIDByName.GetChatIDByNameMock.defaultExpectation.params
		mm_want_ptrs := mmGetChatIDByName.GetChatIDByNameMock.defaultExpectation.paramPtrs

		mm_got := ChatServiceMockGetChatIDByNameParams{ctx, chatname}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetChatIDByName.t.Errorf("ChatServiceMock.GetChatIDByName got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetChatIDByName.GetChatIDByNameMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.chatname != nil && !minimock.Equal(*mm_want_ptrs.chatname, mm_got.chatname) {
				mmGetChatIDByName.t.Errorf("ChatServiceMock.GetChatIDByName got unexpected parameter chatname, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetChatIDByName.GetChatIDByNameMock.defaultExpectation.expectationOrigins.originChatname, *mm_want_ptrs.chatname, mm_got.chatname, minimock.Diff(*mm_want_ptrs.chatname, mm_got.chatname))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetChatIDByName.t.Errorf("ChatServiceMock.GetChatIDByName got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetChatIDByName.GetChatIDByNameMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetChatIDByName.GetChatIDByNameMock.defaultExpectation.results
		if mm_results == nil {
			mmGetChatIDByName.t.Fatal("No results are set for the ChatServiceMock.GetChatIDByName")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmGetChatIDByName.funcGetChatIDByName != nil {
		return mmGetChatIDByName.funcGetChatIDByName(ctx, chatname)
	}
	mmGetChatIDByName.t.Fatalf("Unexpected call to ChatServiceMock.GetChatIDByName. %v %v", ctx, chatname)
	return
}

// GetChatIDByNameAfterCounter returns a count of finished ChatServiceMock.GetChatIDByName invocations
func (mmGetChatIDByName *ChatServiceMock) GetChatIDByNameAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetChatIDByName.afterGetChatIDByNameCounter)
}

// GetChatIDByNameBeforeCounter returns a count of ChatServiceMock.GetChatIDByName invocations
func (mmGetChatIDByName *ChatServiceMock) GetChatIDByNameBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetChatIDByName.beforeGetChatIDByNameCounter)
}

// Calls returns a list of arguments used in each call to ChatServiceMock.GetChatIDByName.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetChatIDByName *mChatServiceMockGetChatIDByName) Calls() []*ChatServiceMockGetChatIDByNameParams {
	mmGetChatIDByName.mutex.RLock()

	argCopy := make([]*ChatServiceMockGetChatIDByNameParams, len(mmGetChatIDByName.callArgs))
	copy(argCopy, mmGetChatIDByName.callArgs)

	mmGetChatIDByName.mutex.RUnlock()

	return argCopy
}

// MinimockGetChatIDByNameDone returns true if the count of the GetChatIDByName invocations corresponds
// the number of defined expectations
func (m *ChatServiceMock) MinimockGetChatIDByNameDone() bool {
	if m.GetChatIDByNameMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetChatIDByNameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetChatIDByNameMock.invocationsDone()
}

// MinimockGetChatIDByNameInspect logs each unmet expectation
func (m *ChatServiceMock) MinimockGetChatIDByNameInspect() {
	for _, e := range m.GetChatIDByNameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServiceMock.GetChatIDByName at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetChatIDByNameCounter := mm_atomic.LoadUint64(&m.afterGetChatIDByNameCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetChatIDByNameMock.defaultExpectation != nil && afterGetChatIDByNameCounter < 1 {
		if m.GetChatIDByNameMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ChatServiceMock.GetChatIDByName at\n%s", m.GetChatIDByNameMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ChatServiceMock.GetChatIDByName at\n%s with params: %#v", m.GetChatIDByNameMock.defaultExpectation.expectationOrigins.origin, *m.GetChatIDByNameMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetChatIDByName != nil && afterGetChatIDByNameCounter < 1 {
		m.t.Errorf("Expected call to ChatServiceMock.GetChatIDByName at\n%s", m.funcGetChatIDByNameOrigin)
	}

	if !m.GetChatIDByNameMock.invocationsDone() && afterGetChatIDByNameCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatServiceMock.GetChatIDByName at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetChatIDByNameMock.expectedInvocations), m.GetChatIDByNameMock.expectedInvocationsOrigin, afterGetChatIDByNameCounter)
	}
}

type mChatServiceMockSendMessage struct {
	optional           bool
	mock               *ChatServiceMock
	defaultExpectation *ChatServiceMockSendMessageExpectation
	expectations       []*ChatServiceMockSendMessageExpectation

	callArgs []*ChatServiceMockSendMessageParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ChatServiceMockSendMessageExpectation specifies expectation struct of the ChatService.SendMessage
type ChatServiceMockSendMessageExpectation struct {
	mock               *ChatServiceMock
	params             *ChatServiceMockSendMessageParams
	paramPtrs          *ChatServiceMockSendMessageParamPtrs
	expectationOrigins ChatServiceMockSendMessageExpectationOrigins
	results            *ChatServiceMockSendMessageResults
	returnOrigin       string
	Counter            uint64
}

// ChatServiceMockSendMessageParams contains parameters of the ChatService.SendMessage
type ChatServiceMockSendMessageParams struct {
	ctx     context.Context
	chatID  int64
	message *chat_v1.Message
}

// ChatServiceMockSendMessageParamPtrs contains pointers to parameters of the ChatService.SendMessage
type ChatServiceMockSendMessageParamPtrs struct {
	ctx     *context.Context
	chatID  *int64
	message **chat_v1.Message
}

// ChatServiceMockSendMessageResults contains results of the ChatService.SendMessage
type ChatServiceMockSendMessageResults struct {
	err error
}

// ChatServiceMockSendMessageOrigins contains origins of expectations of the ChatService.SendMessage
type ChatServiceMockSendMessageExpectationOrigins struct {
	origin        string
	originCtx     string
	originChatID  string
	originMessage string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSendMessage *mChatServiceMockSendMessage) Optional() *mChatServiceMockSendMessage {
	mmSendMessage.optional = true
	return mmSendMessage
}

// Expect sets up expected params for ChatService.SendMessage
func (mmSendMessage *mChatServiceMockSendMessage) Expect(ctx context.Context, chatID int64, message *chat_v1.Message) *mChatServiceMockSendMessage {
	if mmSendMessage.mock.funcSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("ChatServiceMock.SendMessage mock is already set by Set")
	}

	if mmSendMessage.defaultExpectation == nil {
		mmSendMessage.defaultExpectation = &ChatServiceMockSendMessageExpectation{}
	}

	if mmSendMessage.defaultExpectation.paramPtrs != nil {
		mmSendMessage.mock.t.Fatalf("ChatServiceMock.SendMessage mock is already set by ExpectParams functions")
	}

	mmSendMessage.defaultExpectation.params = &ChatServiceMockSendMessageParams{ctx, chatID, message}
	mmSendMessage.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSendMessage.expectations {
		if minimock.Equal(e.params, mmSendMessage.defaultExpectation.params) {
			mmSendMessage.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSendMessage.defaultExpectation.params)
		}
	}

	return mmSendMessage
}

// ExpectCtxParam1 sets up expected param ctx for ChatService.SendMessage
func (mmSendMessage *mChatServiceMockSendMessage) ExpectCtxParam1(ctx context.Context) *mChatServiceMockSendMessage {
	if mmSendMessage.mock.funcSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("ChatServiceMock.SendMessage mock is already set by Set")
	}

	if mmSendMessage.defaultExpectation == nil {
		mmSendMessage.defaultExpectation = &ChatServiceMockSendMessageExpectation{}
	}

	if mmSendMessage.defaultExpectation.params != nil {
		mmSendMessage.mock.t.Fatalf("ChatServiceMock.SendMessage mock is already set by Expect")
	}

	if mmSendMessage.defaultExpectation.paramPtrs == nil {
		mmSendMessage.defaultExpectation.paramPtrs = &ChatServiceMockSendMessageParamPtrs{}
	}
	mmSendMessage.defaultExpectation.paramPtrs.ctx = &ctx
	mmSendMessage.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSendMessage
}

// ExpectChatIDParam2 sets up expected param chatID for ChatService.SendMessage
func (mmSendMessage *mChatServiceMockSendMessage) ExpectChatIDParam2(chatID int64) *mChatServiceMockSendMessage {
	if mmSendMessage.mock.funcSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("ChatServiceMock.SendMessage mock is already set by Set")
	}

	if mmSendMessage.defaultExpectation == nil {
		mmSendMessage.defaultExpectation = &ChatServiceMockSendMessageExpectation{}
	}

	if mmSendMessage.defaultExpectation.params != nil {
		mmSendMessage.mock.t.Fatalf("ChatServiceMock.SendMessage mock is already set by Expect")
	}

	if mmSendMessage.defaultExpectation.paramPtrs == nil {
		mmSendMessage.defaultExpectation.paramPtrs = &ChatServiceMockSendMessageParamPtrs{}
	}
	mmSendMessage.defaultExpectation.paramPtrs.chatID = &chatID
	mmSendMessage.defaultExpectation.expectationOrigins.originChatID = minimock.CallerInfo(1)

	return mmSendMessage
}

// ExpectMessageParam3 sets up expected param message for ChatService.SendMessage
func (mmSendMessage *mChatServiceMockSendMessage) ExpectMessageParam3(message *chat_v1.Message) *mChatServiceMockSendMessage {
	if mmSendMessage.mock.funcSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("ChatServiceMock.SendMessage mock is already set by Set")
	}

	if mmSendMessage.defaultExpectation == nil {
		mmSendMessage.defaultExpectation = &ChatServiceMockSendMessageExpectation{}
	}

	if mmSendMessage.defaultExpectation.params != nil {
		mmSendMessage.mock.t.Fatalf("ChatServiceMock.SendMessage mock is already set by Expect")
	}

	if mmSendMessage.defaultExpectation.paramPtrs == nil {
		mmSendMessage.defaultExpectation.paramPtrs = &ChatServiceMockSendMessageParamPtrs{}
	}
	mmSendMessage.defaultExpectation.paramPtrs.message = &message
	mmSendMessage.defaultExpectation.expectationOrigins.originMessage = minimock.CallerInfo(1)

	return mmSendMessage
}

// Inspect accepts an inspector function that has same arguments as the ChatService.SendMessage
func (mmSendMessage *mChatServiceMockSendMessage) Inspect(f func(ctx context.Context, chatID int64, message *chat_v1.Message)) *mChatServiceMockSendMessage {
	if mmSendMessage.mock.inspectFuncSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("Inspect function is already set for ChatServiceMock.SendMessage")
	}

	mmSendMessage.mock.inspectFuncSendMessage = f

	return mmSendMessage
}

// Return sets up results that will be returned by ChatService.SendMessage
func (mmSendMessage *mChatServiceMockSendMessage) Return(err error) *ChatServiceMock {
	if mmSendMessage.mock.funcSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("ChatServiceMock.SendMessage mock is already set by Set")
	}

	if mmSendMessage.defaultExpectation == nil {
		mmSendMessage.defaultExpectation = &ChatServiceMockSendMessageExpectation{mock: mmSendMessage.mock}
	}
	mmSendMessage.defaultExpectation.results = &ChatServiceMockSendMessageResults{err}
	mmSendMessage.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSendMessage.mock
}

// Set uses given function f to mock the ChatService.SendMessage method
func (mmSendMessage *mChatServiceMockSendMessage) Set(f func(ctx context.Context, chatID int64, message *chat_v1.Message) (err error)) *ChatServiceMock {
	if mmSendMessage.defaultExpectation != nil {
		mmSendMessage.mock.t.Fatalf("Default expectation is already set for the ChatService.SendMessage method")
	}

	if len(mmSendMessage.expectations) > 0 {
		mmSendMessage.mock.t.Fatalf("Some expectations are already set for the ChatService.SendMessage method")
	}

	mmSendMessage.mock.funcSendMessage = f
	mmSendMessage.mock.funcSendMessageOrigin = minimock.CallerInfo(1)
	return mmSendMessage.mock
}

// When sets expectation for the ChatService.SendMessage which will trigger the result defined by the following
// Then helper
func (mmSendMessage *mChatServiceMockSendMessage) When(ctx context.Context, chatID int64, message *chat_v1.Message) *ChatServiceMockSendMessageExpectation {
	if mmSendMessage.mock.funcSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("ChatServiceMock.SendMessage mock is already set by Set")
	}

	expectation := &ChatServiceMockSendMessageExpectation{
		mock:               mmSendMessage.mock,
		params:             &ChatServiceMockSendMessageParams{ctx, chatID, message},
		expectationOrigins: ChatServiceMockSendMessageExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSendMessage.expectations = append(mmSendMessage.expectations, expectation)
	return expectation
}

// Then sets up ChatService.SendMessage return parameters for the expectation previously defined by the When method
func (e *ChatServiceMockSendMessageExpectation) Then(err error) *ChatServiceMock {
	e.results = &ChatServiceMockSendMessageResults{err}
	return e.mock
}

// Times sets number of times ChatService.SendMessage should be invoked
func (mmSendMessage *mChatServiceMockSendMessage) Times(n uint64) *mChatServiceMockSendMessage {
	if n == 0 {
		mmSendMessage.mock.t.Fatalf("Times of ChatServiceMock.SendMessage mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSendMessage.expectedInvocations, n)
	mmSendMessage.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSendMessage
}

func (mmSendMessage *mChatServiceMockSendMessage) invocationsDone() bool {
	if len(mmSendMessage.expectations) == 0 && mmSendMessage.defaultExpectation == nil && mmSendMessage.mock.funcSendMessage == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSendMessage.mock.afterSendMessageCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSendMessage.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SendMessage implements mm_service.ChatService
func (mmSendMessage *ChatServiceMock) SendMessage(ctx context.Context, chatID int64, message *chat_v1.Message) (err error) {
	mm_atomic.AddUint64(&mmSendMessage.beforeSendMessageCounter, 1)
	defer mm_atomic.AddUint64(&mmSendMessage.afterSendMessageCounter, 1)

	mmSendMessage.t.Helper()

	if mmSendMessage.inspectFuncSendMessage != nil {
		mmSendMessage.inspectFuncSendMessage(ctx, chatID, message)
	}

	mm_params := ChatServiceMockSendMessageParams{ctx, chatID, message}

	// Record call args
	mmSendMessage.SendMessageMock.mutex.Lock()
	mmSendMessage.SendMessageMock.callArgs = append(mmSendMessage.SendMessageMock.callArgs, &mm_params)
	mmSendMessage.SendMessageMock.mutex.Unlock()

	for _, e := range mmSendMessage.SendMessageMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSendMessage.SendMessageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSendMessage.SendMessageMock.defaultExpectation.Counter, 1)
		mm_want := mmSendMessage.SendMessageMock.defaultExpectation.params
		mm_want_ptrs := mmSendMessage.SendMessageMock.defaultExpectation.paramPtrs

		mm_got := ChatServiceMockSendMessageParams{ctx, chatID, message}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSendMessage.t.Errorf("ChatServiceMock.SendMessage got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSendMessage.SendMessageMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.chatID != nil && !minimock.Equal(*mm_want_ptrs.chatID, mm_got.chatID) {
				mmSendMessage.t.Errorf("ChatServiceMock.SendMessage got unexpected parameter chatID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSendMessage.SendMessageMock.defaultExpectation.expectationOrigins.originChatID, *mm_want_ptrs.chatID, mm_got.chatID, minimock.Diff(*mm_want_ptrs.chatID, mm_got.chatID))
			}

			if mm_want_ptrs.message != nil && !minimock.Equal(*mm_want_ptrs.message, mm_got.message) {
				mmSendMessage.t.Errorf("ChatServiceMock.SendMessage got unexpected parameter message, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSendMessage.SendMessageMock.defaultExpectation.expectationOrigins.originMessage, *mm_want_ptrs.message, mm_got.message, minimock.Diff(*mm_want_ptrs.message, mm_got.message))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSendMessage.t.Errorf("ChatServiceMock.SendMessage got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSendMessage.SendMessageMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSendMessage.SendMessageMock.defaultExpectation.results
		if mm_results == nil {
			mmSendMessage.t.Fatal("No results are set for the ChatServiceMock.SendMessage")
		}
		return (*mm_results).err
	}
	if mmSendMessage.funcSendMessage != nil {
		return mmSendMessage.funcSendMessage(ctx, chatID, message)
	}
	mmSendMessage.t.Fatalf("Unexpected call to ChatServiceMock.SendMessage. %v %v %v", ctx, chatID, message)
	return
}

// SendMessageAfterCounter returns a count of finished ChatServiceMock.SendMessage invocations
func (mmSendMessage *ChatServiceMock) SendMessageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendMessage.afterSendMessageCounter)
}

// SendMessageBeforeCounter returns a count of ChatServiceMock.SendMessage invocations
func (mmSendMessage *ChatServiceMock) SendMessageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendMessage.beforeSendMessageCounter)
}

// Calls returns a list of arguments used in each call to ChatServiceMock.SendMessage.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSendMessage *mChatServiceMockSendMessage) Calls() []*ChatServiceMockSendMessageParams {
	mmSendMessage.mutex.RLock()

	argCopy := make([]*ChatServiceMockSendMessageParams, len(mmSendMessage.callArgs))
	copy(argCopy, mmSendMessage.callArgs)

	mmSendMessage.mutex.RUnlock()

	return argCopy
}

// MinimockSendMessageDone returns true if the count of the SendMessage invocations corresponds
// the number of defined expectations
func (m *ChatServiceMock) MinimockSendMessageDone() bool {
	if m.SendMessageMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SendMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SendMessageMock.invocationsDone()
}

// MinimockSendMessageInspect logs each unmet expectation
func (m *ChatServiceMock) MinimockSendMessageInspect() {
	for _, e := range m.SendMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServiceMock.SendMessage at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSendMessageCounter := mm_atomic.LoadUint64(&m.afterSendMessageCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SendMessageMock.defaultExpectation != nil && afterSendMessageCounter < 1 {
		if m.SendMessageMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ChatServiceMock.SendMessage at\n%s", m.SendMessageMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ChatServiceMock.SendMessage at\n%s with params: %#v", m.SendMessageMock.defaultExpectation.expectationOrigins.origin, *m.SendMessageMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSendMessage != nil && afterSendMessageCounter < 1 {
		m.t.Errorf("Expected call to ChatServiceMock.SendMessage at\n%s", m.funcSendMessageOrigin)
	}

	if !m.SendMessageMock.invocationsDone() && afterSendMessageCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatServiceMock.SendMessage at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SendMessageMock.expectedInvocations), m.SendMessageMock.expectedInvocationsOrigin, afterSendMessageCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ChatServiceMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockConnectChatInspect()

			m.MinimockCreateChatInspect()

			m.MinimockDeleteChatInspect()

			m.MinimockGetChatIDByNameInspect()

			m.MinimockSendMessageInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ChatServiceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ChatServiceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockConnectChatDone() &&
		m.MinimockCreateChatDone() &&
		m.MinimockDeleteChatDone() &&
		m.MinimockGetChatIDByNameDone() &&
		m.MinimockSendMessageDone()
}

// Code generated by http://github.com/gojuno/minimock (v3.4.1). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/valek177/chat-server/internal/repository.ChatRepository -o chat_repository_minimock.go -n ChatRepositoryMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/valek177/chat-server/grpc/pkg/chat_v1"
)

// ChatRepositoryMock implements mm_repository.ChatRepository
type ChatRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreateChat          func(ctx context.Context, req *chat_v1.CreateChatRequest) (i1 int64, err error)
	funcCreateChatOrigin    string
	inspectFuncCreateChat   func(ctx context.Context, req *chat_v1.CreateChatRequest)
	afterCreateChatCounter  uint64
	beforeCreateChatCounter uint64
	CreateChatMock          mChatRepositoryMockCreateChat

	funcDeleteChat          func(ctx context.Context, id int64) (err error)
	funcDeleteChatOrigin    string
	inspectFuncDeleteChat   func(ctx context.Context, id int64)
	afterDeleteChatCounter  uint64
	beforeDeleteChatCounter uint64
	DeleteChatMock          mChatRepositoryMockDeleteChat

	funcGetChatIDByName          func(ctx context.Context, chatname string) (i1 int64, err error)
	funcGetChatIDByNameOrigin    string
	inspectFuncGetChatIDByName   func(ctx context.Context, chatname string)
	afterGetChatIDByNameCounter  uint64
	beforeGetChatIDByNameCounter uint64
	GetChatIDByNameMock          mChatRepositoryMockGetChatIDByName
}

// NewChatRepositoryMock returns a mock for mm_repository.ChatRepository
func NewChatRepositoryMock(t minimock.Tester) *ChatRepositoryMock {
	m := &ChatRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateChatMock = mChatRepositoryMockCreateChat{mock: m}
	m.CreateChatMock.callArgs = []*ChatRepositoryMockCreateChatParams{}

	m.DeleteChatMock = mChatRepositoryMockDeleteChat{mock: m}
	m.DeleteChatMock.callArgs = []*ChatRepositoryMockDeleteChatParams{}

	m.GetChatIDByNameMock = mChatRepositoryMockGetChatIDByName{mock: m}
	m.GetChatIDByNameMock.callArgs = []*ChatRepositoryMockGetChatIDByNameParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mChatRepositoryMockCreateChat struct {
	optional           bool
	mock               *ChatRepositoryMock
	defaultExpectation *ChatRepositoryMockCreateChatExpectation
	expectations       []*ChatRepositoryMockCreateChatExpectation

	callArgs []*ChatRepositoryMockCreateChatParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ChatRepositoryMockCreateChatExpectation specifies expectation struct of the ChatRepository.CreateChat
type ChatRepositoryMockCreateChatExpectation struct {
	mock               *ChatRepositoryMock
	params             *ChatRepositoryMockCreateChatParams
	paramPtrs          *ChatRepositoryMockCreateChatParamPtrs
	expectationOrigins ChatRepositoryMockCreateChatExpectationOrigins
	results            *ChatRepositoryMockCreateChatResults
	returnOrigin       string
	Counter            uint64
}

// ChatRepositoryMockCreateChatParams contains parameters of the ChatRepository.CreateChat
type ChatRepositoryMockCreateChatParams struct {
	ctx context.Context
	req *chat_v1.CreateChatRequest
}

// ChatRepositoryMockCreateChatParamPtrs contains pointers to parameters of the ChatRepository.CreateChat
type ChatRepositoryMockCreateChatParamPtrs struct {
	ctx *context.Context
	req **chat_v1.CreateChatRequest
}

// ChatRepositoryMockCreateChatResults contains results of the ChatRepository.CreateChat
type ChatRepositoryMockCreateChatResults struct {
	i1  int64
	err error
}

// ChatRepositoryMockCreateChatOrigins contains origins of expectations of the ChatRepository.CreateChat
type ChatRepositoryMockCreateChatExpectationOrigins struct {
	origin    string
	originCtx string
	originReq string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateChat *mChatRepositoryMockCreateChat) Optional() *mChatRepositoryMockCreateChat {
	mmCreateChat.optional = true
	return mmCreateChat
}

// Expect sets up expected params for ChatRepository.CreateChat
func (mmCreateChat *mChatRepositoryMockCreateChat) Expect(ctx context.Context, req *chat_v1.CreateChatRequest) *mChatRepositoryMockCreateChat {
	if mmCreateChat.mock.funcCreateChat != nil {
		mmCreateChat.mock.t.Fatalf("ChatRepositoryMock.CreateChat mock is already set by Set")
	}

	if mmCreateChat.defaultExpectation == nil {
		mmCreateChat.defaultExpectation = &ChatRepositoryMockCreateChatExpectation{}
	}

	if mmCreateChat.defaultExpectation.paramPtrs != nil {
		mmCreateChat.mock.t.Fatalf("ChatRepositoryMock.CreateChat mock is already set by ExpectParams functions")
	}

	mmCreateChat.defaultExpectation.params = &ChatRepositoryMockCreateChatParams{ctx, req}
	mmCreateChat.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateChat.expectations {
		if minimock.Equal(e.params, mmCreateChat.defaultExpectation.params) {
			mmCreateChat.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateChat.defaultExpectation.params)
		}
	}

	return mmCreateChat
}

// ExpectCtxParam1 sets up expected param ctx for ChatRepository.CreateChat
func (mmCreateChat *mChatRepositoryMockCreateChat) ExpectCtxParam1(ctx context.Context) *mChatRepositoryMockCreateChat {
	if mmCreateChat.mock.funcCreateChat != nil {
		mmCreateChat.mock.t.Fatalf("ChatRepositoryMock.CreateChat mock is already set by Set")
	}

	if mmCreateChat.defaultExpectation == nil {
		mmCreateChat.defaultExpectation = &ChatRepositoryMockCreateChatExpectation{}
	}

	if mmCreateChat.defaultExpectation.params != nil {
		mmCreateChat.mock.t.Fatalf("ChatRepositoryMock.CreateChat mock is already set by Expect")
	}

	if mmCreateChat.defaultExpectation.paramPtrs == nil {
		mmCreateChat.defaultExpectation.paramPtrs = &ChatRepositoryMockCreateChatParamPtrs{}
	}
	mmCreateChat.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateChat.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateChat
}

// ExpectReqParam2 sets up expected param req for ChatRepository.CreateChat
func (mmCreateChat *mChatRepositoryMockCreateChat) ExpectReqParam2(req *chat_v1.CreateChatRequest) *mChatRepositoryMockCreateChat {
	if mmCreateChat.mock.funcCreateChat != nil {
		mmCreateChat.mock.t.Fatalf("ChatRepositoryMock.CreateChat mock is already set by Set")
	}

	if mmCreateChat.defaultExpectation == nil {
		mmCreateChat.defaultExpectation = &ChatRepositoryMockCreateChatExpectation{}
	}

	if mmCreateChat.defaultExpectation.params != nil {
		mmCreateChat.mock.t.Fatalf("ChatRepositoryMock.CreateChat mock is already set by Expect")
	}

	if mmCreateChat.defaultExpectation.paramPtrs == nil {
		mmCreateChat.defaultExpectation.paramPtrs = &ChatRepositoryMockCreateChatParamPtrs{}
	}
	mmCreateChat.defaultExpectation.paramPtrs.req = &req
	mmCreateChat.defaultExpectation.expectationOrigins.originReq = minimock.CallerInfo(1)

	return mmCreateChat
}

// Inspect accepts an inspector function that has same arguments as the ChatRepository.CreateChat
func (mmCreateChat *mChatRepositoryMockCreateChat) Inspect(f func(ctx context.Context, req *chat_v1.CreateChatRequest)) *mChatRepositoryMockCreateChat {
	if mmCreateChat.mock.inspectFuncCreateChat != nil {
		mmCreateChat.mock.t.Fatalf("Inspect function is already set for ChatRepositoryMock.CreateChat")
	}

	mmCreateChat.mock.inspectFuncCreateChat = f

	return mmCreateChat
}

// Return sets up results that will be returned by ChatRepository.CreateChat
func (mmCreateChat *mChatRepositoryMockCreateChat) Return(i1 int64, err error) *ChatRepositoryMock {
	if mmCreateChat.mock.funcCreateChat != nil {
		mmCreateChat.mock.t.Fatalf("ChatRepositoryMock.CreateChat mock is already set by Set")
	}

	if mmCreateChat.defaultExpectation == nil {
		mmCreateChat.defaultExpectation = &ChatRepositoryMockCreateChatExpectation{mock: mmCreateChat.mock}
	}
	mmCreateChat.defaultExpectation.results = &ChatRepositoryMockCreateChatResults{i1, err}
	mmCreateChat.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateChat.mock
}

// Set uses given function f to mock the ChatRepository.CreateChat method
func (mmCreateChat *mChatRepositoryMockCreateChat) Set(f func(ctx context.Context, req *chat_v1.CreateChatRequest) (i1 int64, err error)) *ChatRepositoryMock {
	if mmCreateChat.defaultExpectation != nil {
		mmCreateChat.mock.t.Fatalf("Default expectation is already set for the ChatRepository.CreateChat method")
	}

	if len(mmCreateChat.expectations) > 0 {
		mmCreateChat.mock.t.Fatalf("Some expectations are already set for the ChatRepository.CreateChat method")
	}

	mmCreateChat.mock.funcCreateChat = f
	mmCreateChat.mock.funcCreateChatOrigin = minimock.CallerInfo(1)
	return mmCreateChat.mock
}

// When sets expectation for the ChatRepository.CreateChat which will trigger the result defined by the following
// Then helper
func (mmCreateChat *mChatRepositoryMockCreateChat) When(ctx context.Context, req *chat_v1.CreateChatRequest) *ChatRepositoryMockCreateChatExpectation {
	if mmCreateChat.mock.funcCreateChat != nil {
		mmCreateChat.mock.t.Fatalf("ChatRepositoryMock.CreateChat mock is already set by Set")
	}

	expectation := &ChatRepositoryMockCreateChatExpectation{
		mock:               mmCreateChat.mock,
		params:             &ChatRepositoryMockCreateChatParams{ctx, req},
		expectationOrigins: ChatRepositoryMockCreateChatExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateChat.expectations = append(mmCreateChat.expectations, expectation)
	return expectation
}

// Then sets up ChatRepository.CreateChat return parameters for the expectation previously defined by the When method
func (e *ChatRepositoryMockCreateChatExpectation) Then(i1 int64, err error) *ChatRepositoryMock {
	e.results = &ChatRepositoryMockCreateChatResults{i1, err}
	return e.mock
}

// Times sets number of times ChatRepository.CreateChat should be invoked
func (mmCreateChat *mChatRepositoryMockCreateChat) Times(n uint64) *mChatRepositoryMockCreateChat {
	if n == 0 {
		mmCreateChat.mock.t.Fatalf("Times of ChatRepositoryMock.CreateChat mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateChat.expectedInvocations, n)
	mmCreateChat.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateChat
}

func (mmCreateChat *mChatRepositoryMockCreateChat) invocationsDone() bool {
	if len(mmCreateChat.expectations) == 0 && mmCreateChat.defaultExpectation == nil && mmCreateChat.mock.funcCreateChat == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateChat.mock.afterCreateChatCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateChat.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateChat implements mm_repository.ChatRepository
func (mmCreateChat *ChatRepositoryMock) CreateChat(ctx context.Context, req *chat_v1.CreateChatRequest) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmCreateChat.beforeCreateChatCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateChat.afterCreateChatCounter, 1)

	mmCreateChat.t.Helper()

	if mmCreateChat.inspectFuncCreateChat != nil {
		mmCreateChat.inspectFuncCreateChat(ctx, req)
	}

	mm_params := ChatRepositoryMockCreateChatParams{ctx, req}

	// Record call args
	mmCreateChat.CreateChatMock.mutex.Lock()
	mmCreateChat.CreateChatMock.callArgs = append(mmCreateChat.CreateChatMock.callArgs, &mm_params)
	mmCreateChat.CreateChatMock.mutex.Unlock()

	for _, e := range mmCreateChat.CreateChatMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCreateChat.CreateChatMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateChat.CreateChatMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateChat.CreateChatMock.defaultExpectation.params
		mm_want_ptrs := mmCreateChat.CreateChatMock.defaultExpectation.paramPtrs

		mm_got := ChatRepositoryMockCreateChatParams{ctx, req}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateChat.t.Errorf("ChatRepositoryMock.CreateChat got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateChat.CreateChatMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.req != nil && !minimock.Equal(*mm_want_ptrs.req, mm_got.req) {
				mmCreateChat.t.Errorf("ChatRepositoryMock.CreateChat got unexpected parameter req, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateChat.CreateChatMock.defaultExpectation.expectationOrigins.originReq, *mm_want_ptrs.req, mm_got.req, minimock.Diff(*mm_want_ptrs.req, mm_got.req))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateChat.t.Errorf("ChatRepositoryMock.CreateChat got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateChat.CreateChatMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateChat.CreateChatMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateChat.t.Fatal("No results are set for the ChatRepositoryMock.CreateChat")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCreateChat.funcCreateChat != nil {
		return mmCreateChat.funcCreateChat(ctx, req)
	}
	mmCreateChat.t.Fatalf("Unexpected call to ChatRepositoryMock.CreateChat. %v %v", ctx, req)
	return
}

// CreateChatAfterCounter returns a count of finished ChatRepositoryMock.CreateChat invocations
func (mmCreateChat *ChatRepositoryMock) CreateChatAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateChat.afterCreateChatCounter)
}

// CreateChatBeforeCounter returns a count of ChatRepositoryMock.CreateChat invocations
func (mmCreateChat *ChatRepositoryMock) CreateChatBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateChat.beforeCreateChatCounter)
}

// Calls returns a list of arguments used in each call to ChatRepositoryMock.CreateChat.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateChat *mChatRepositoryMockCreateChat) Calls() []*ChatRepositoryMockCreateChatParams {
	mmCreateChat.mutex.RLock()

	argCopy := make([]*ChatRepositoryMockCreateChatParams, len(mmCreateChat.callArgs))
	copy(argCopy, mmCreateChat.callArgs)

	mmCreateChat.mutex.RUnlock()

	return argCopy
}

// MinimockCreateChatDone returns true if the count of the CreateChat invocations corresponds
// the number of defined expectations
func (m *ChatRepositoryMock) MinimockCreateChatDone() bool {
	if m.CreateChatMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateChatMock.invocationsDone()
}

// MinimockCreateChatInspect logs each unmet expectation
func (m *ChatRepositoryMock) MinimockCreateChatInspect() {
	for _, e := range m.CreateChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatRepositoryMock.CreateChat at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateChatCounter := mm_atomic.LoadUint64(&m.afterCreateChatCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateChatMock.defaultExpectation != nil && afterCreateChatCounter < 1 {
		if m.CreateChatMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ChatRepositoryMock.CreateChat at\n%s", m.CreateChatMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ChatRepositoryMock.CreateChat at\n%s with params: %#v", m.CreateChatMock.defaultExpectation.expectationOrigins.origin, *m.CreateChatMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateChat != nil && afterCreateChatCounter < 1 {
		m.t.Errorf("Expected call to ChatRepositoryMock.CreateChat at\n%s", m.funcCreateChatOrigin)
	}

	if !m.CreateChatMock.invocationsDone() && afterCreateChatCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatRepositoryMock.CreateChat at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateChatMock.expectedInvocations), m.CreateChatMock.expectedInvocationsOrigin, afterCreateChatCounter)
	}
}

type mChatRepositoryMockDeleteChat struct {
	optional           bool
	mock               *ChatRepositoryMock
	defaultExpectation *ChatRepositoryMockDeleteChatExpectation
	expectations       []*ChatRepositoryMockDeleteChatExpectation

	callArgs []*ChatRepositoryMockDeleteChatParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ChatRepositoryMockDeleteChatExpectation specifies expectation struct of the ChatRepository.DeleteChat
type ChatRepositoryMockDeleteChatExpectation struct {
	mock               *ChatRepositoryMock
	params             *ChatRepositoryMockDeleteChatParams
	paramPtrs          *ChatRepositoryMockDeleteChatParamPtrs
	expectationOrigins ChatRepositoryMockDeleteChatExpectationOrigins
	results            *ChatRepositoryMockDeleteChatResults
	returnOrigin       string
	Counter            uint64
}

// ChatRepositoryMockDeleteChatParams contains parameters of the ChatRepository.DeleteChat
type ChatRepositoryMockDeleteChatParams struct {
	ctx context.Context
	id  int64
}

// ChatRepositoryMockDeleteChatParamPtrs contains pointers to parameters of the ChatRepository.DeleteChat
type ChatRepositoryMockDeleteChatParamPtrs struct {
	ctx *context.Context
	id  *int64
}

// ChatRepositoryMockDeleteChatResults contains results of the ChatRepository.DeleteChat
type ChatRepositoryMockDeleteChatResults struct {
	err error
}

// ChatRepositoryMockDeleteChatOrigins contains origins of expectations of the ChatRepository.DeleteChat
type ChatRepositoryMockDeleteChatExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteChat *mChatRepositoryMockDeleteChat) Optional() *mChatRepositoryMockDeleteChat {
	mmDeleteChat.optional = true
	return mmDeleteChat
}

// Expect sets up expected params for ChatRepository.DeleteChat
func (mmDeleteChat *mChatRepositoryMockDeleteChat) Expect(ctx context.Context, id int64) *mChatRepositoryMockDeleteChat {
	if mmDeleteChat.mock.funcDeleteChat != nil {
		mmDeleteChat.mock.t.Fatalf("ChatRepositoryMock.DeleteChat mock is already set by Set")
	}

	if mmDeleteChat.defaultExpectation == nil {
		mmDeleteChat.defaultExpectation = &ChatRepositoryMockDeleteChatExpectation{}
	}

	if mmDeleteChat.defaultExpectation.paramPtrs != nil {
		mmDeleteChat.mock.t.Fatalf("ChatRepositoryMock.DeleteChat mock is already set by ExpectParams functions")
	}

	mmDeleteChat.defaultExpectation.params = &ChatRepositoryMockDeleteChatParams{ctx, id}
	mmDeleteChat.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteChat.expectations {
		if minimock.Equal(e.params, mmDeleteChat.defaultExpectation.params) {
			mmDeleteChat.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteChat.defaultExpectation.params)
		}
	}

	return mmDeleteChat
}

// ExpectCtxParam1 sets up expected param ctx for ChatRepository.DeleteChat
func (mmDeleteChat *mChatRepositoryMockDeleteChat) ExpectCtxParam1(ctx context.Context) *mChatRepositoryMockDeleteChat {
	if mmDeleteChat.mock.funcDeleteChat != nil {
		mmDeleteChat.mock.t.Fatalf("ChatRepositoryMock.DeleteChat mock is already set by Set")
	}

	if mmDeleteChat.defaultExpectation == nil {
		mmDeleteChat.defaultExpectation = &ChatRepositoryMockDeleteChatExpectation{}
	}

	if mmDeleteChat.defaultExpectation.params != nil {
		mmDeleteChat.mock.t.Fatalf("ChatRepositoryMock.DeleteChat mock is already set by Expect")
	}

	if mmDeleteChat.defaultExpectation.paramPtrs == nil {
		mmDeleteChat.defaultExpectation.paramPtrs = &ChatRepositoryMockDeleteChatParamPtrs{}
	}
	mmDeleteChat.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteChat.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteChat
}

// ExpectIdParam2 sets up expected param id for ChatRepository.DeleteChat
func (mmDeleteChat *mChatRepositoryMockDeleteChat) ExpectIdParam2(id int64) *mChatRepositoryMockDeleteChat {
	if mmDeleteChat.mock.funcDeleteChat != nil {
		mmDeleteChat.mock.t.Fatalf("ChatRepositoryMock.DeleteChat mock is already set by Set")
	}

	if mmDeleteChat.defaultExpectation == nil {
		mmDeleteChat.defaultExpectation = &ChatRepositoryMockDeleteChatExpectation{}
	}

	if mmDeleteChat.defaultExpectation.params != nil {
		mmDeleteChat.mock.t.Fatalf("ChatRepositoryMock.DeleteChat mock is already set by Expect")
	}

	if mmDeleteChat.defaultExpectation.paramPtrs == nil {
		mmDeleteChat.defaultExpectation.paramPtrs = &ChatRepositoryMockDeleteChatParamPtrs{}
	}
	mmDeleteChat.defaultExpectation.paramPtrs.id = &id
	mmDeleteChat.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmDeleteChat
}

// Inspect accepts an inspector function that has same arguments as the ChatRepository.DeleteChat
func (mmDeleteChat *mChatRepositoryMockDeleteChat) Inspect(f func(ctx context.Context, id int64)) *mChatRepositoryMockDeleteChat {
	if mmDeleteChat.mock.inspectFuncDeleteChat != nil {
		mmDeleteChat.mock.t.Fatalf("Inspect function is already set for ChatRepositoryMock.DeleteChat")
	}

	mmDeleteChat.mock.inspectFuncDeleteChat = f

	return mmDeleteChat
}

// Return sets up results that will be returned by ChatRepository.DeleteChat
func (mmDeleteChat *mChatRepositoryMockDeleteChat) Return(err error) *ChatRepositoryMock {
	if mmDeleteChat.mock.funcDeleteChat != nil {
		mmDeleteChat.mock.t.Fatalf("ChatRepositoryMock.DeleteChat mock is already set by Set")
	}

	if mmDeleteChat.defaultExpectation == nil {
		mmDeleteChat.defaultExpectation = &ChatRepositoryMockDeleteChatExpectation{mock: mmDeleteChat.mock}
	}
	mmDeleteChat.defaultExpectation.results = &ChatRepositoryMockDeleteChatResults{err}
	mmDeleteChat.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteChat.mock
}

// Set uses given function f to mock the ChatRepository.DeleteChat method
func (mmDeleteChat *mChatRepositoryMockDeleteChat) Set(f func(ctx context.Context, id int64) (err error)) *ChatRepositoryMock {
	if mmDeleteChat.defaultExpectation != nil {
		mmDeleteChat.mock.t.Fatalf("Default expectation is already set for the ChatRepository.DeleteChat method")
	}

	if len(mmDeleteChat.expectations) > 0 {
		mmDeleteChat.mock.t.Fatalf("Some expectations are already set for the ChatRepository.DeleteChat method")
	}

	mmDeleteChat.mock.funcDeleteChat = f
	mmDeleteChat.mock.funcDeleteChatOrigin = minimock.CallerInfo(1)
	return mmDeleteChat.mock
}

// When sets expectation for the ChatRepository.DeleteChat which will trigger the result defined by the following
// Then helper
func (mmDeleteChat *mChatRepositoryMockDeleteChat) When(ctx context.Context, id int64) *ChatRepositoryMockDeleteChatExpectation {
	if mmDeleteChat.mock.funcDeleteChat != nil {
		mmDeleteChat.mock.t.Fatalf("ChatRepositoryMock.DeleteChat mock is already set by Set")
	}

	expectation := &ChatRepositoryMockDeleteChatExpectation{
		mock:               mmDeleteChat.mock,
		params:             &ChatRepositoryMockDeleteChatParams{ctx, id},
		expectationOrigins: ChatRepositoryMockDeleteChatExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteChat.expectations = append(mmDeleteChat.expectations, expectation)
	return expectation
}

// Then sets up ChatRepository.DeleteChat return parameters for the expectation previously defined by the When method
func (e *ChatRepositoryMockDeleteChatExpectation) Then(err error) *ChatRepositoryMock {
	e.results = &ChatRepositoryMockDeleteChatResults{err}
	return e.mock
}

// Times sets number of times ChatRepository.DeleteChat should be invoked
func (mmDeleteChat *mChatRepositoryMockDeleteChat) Times(n uint64) *mChatRepositoryMockDeleteChat {
	if n == 0 {
		mmDeleteChat.mock.t.Fatalf("Times of ChatRepositoryMock.DeleteChat mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteChat.expectedInvocations, n)
	mmDeleteChat.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteChat
}

func (mmDeleteChat *mChatRepositoryMockDeleteChat) invocationsDone() bool {
	if len(mmDeleteChat.expectations) == 0 && mmDeleteChat.defaultExpectation == nil && mmDeleteChat.mock.funcDeleteChat == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteChat.mock.afterDeleteChatCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteChat.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteChat implements mm_repository.ChatRepository
func (mmDeleteChat *ChatRepositoryMock) DeleteChat(ctx context.Context, id int64) (err error) {
	mm_atomic.AddUint64(&mmDeleteChat.beforeDeleteChatCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteChat.afterDeleteChatCounter, 1)

	mmDeleteChat.t.Helper()

	if mmDeleteChat.inspectFuncDeleteChat != nil {
		mmDeleteChat.inspectFuncDeleteChat(ctx, id)
	}

	mm_params := ChatRepositoryMockDeleteChatParams{ctx, id}

	// Record call args
	mmDeleteChat.DeleteChatMock.mutex.Lock()
	mmDeleteChat.DeleteChatMock.callArgs = append(mmDeleteChat.DeleteChatMock.callArgs, &mm_params)
	mmDeleteChat.DeleteChatMock.mutex.Unlock()

	for _, e := range mmDeleteChat.DeleteChatMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteChat.DeleteChatMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteChat.DeleteChatMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteChat.DeleteChatMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteChat.DeleteChatMock.defaultExpectation.paramPtrs

		mm_got := ChatRepositoryMockDeleteChatParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteChat.t.Errorf("ChatRepositoryMock.DeleteChat got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteChat.DeleteChatMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmDeleteChat.t.Errorf("ChatRepositoryMock.DeleteChat got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteChat.DeleteChatMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteChat.t.Errorf("ChatRepositoryMock.DeleteChat got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteChat.DeleteChatMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteChat.DeleteChatMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteChat.t.Fatal("No results are set for the ChatRepositoryMock.DeleteChat")
		}
		return (*mm_results).err
	}
	if mmDeleteChat.funcDeleteChat != nil {
		return mmDeleteChat.funcDeleteChat(ctx, id)
	}
	mmDeleteChat.t.Fatalf("Unexpected call to ChatRepositoryMock.DeleteChat. %v %v", ctx, id)
	return
}

// DeleteChatAfterCounter returns a count of finished ChatRepositoryMock.DeleteChat invocations
func (mmDeleteChat *ChatRepositoryMock) DeleteChatAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteChat.afterDeleteChatCounter)
}

// DeleteChatBeforeCounter returns a count of ChatRepositoryMock.DeleteChat invocations
func (mmDeleteChat *ChatRepositoryMock) DeleteChatBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteChat.beforeDeleteChatCounter)
}

// Calls returns a list of arguments used in each call to ChatRepositoryMock.DeleteChat.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteChat *mChatRepositoryMockDeleteChat) Calls() []*ChatRepositoryMockDeleteChatParams {
	mmDeleteChat.mutex.RLock()

	argCopy := make([]*ChatRepositoryMockDeleteChatParams, len(mmDeleteChat.callArgs))
	copy(argCopy, mmDeleteChat.callArgs)

	mmDeleteChat.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteChatDone returns true if the count of the DeleteChat invocations corresponds
// the number of defined expectations
func (m *ChatRepositoryMock) MinimockDeleteChatDone() bool {
	if m.DeleteChatMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteChatMock.invocationsDone()
}

// MinimockDeleteChatInspect logs each unmet expectation
func (m *ChatRepositoryMock) MinimockDeleteChatInspect() {
	for _, e := range m.DeleteChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatRepositoryMock.DeleteChat at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteChatCounter := mm_atomic.LoadUint64(&m.afterDeleteChatCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteChatMock.defaultExpectation != nil && afterDeleteChatCounter < 1 {
		if m.DeleteChatMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ChatRepositoryMock.DeleteChat at\n%s", m.DeleteChatMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ChatRepositoryMock.DeleteChat at\n%s with params: %#v", m.DeleteChatMock.defaultExpectation.expectationOrigins.origin, *m.DeleteChatMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteChat != nil && afterDeleteChatCounter < 1 {
		m.t.Errorf("Expected call to ChatRepositoryMock.DeleteChat at\n%s", m.funcDeleteChatOrigin)
	}

	if !m.DeleteChatMock.invocationsDone() && afterDeleteChatCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatRepositoryMock.DeleteChat at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteChatMock.expectedInvocations), m.DeleteChatMock.expectedInvocationsOrigin, afterDeleteChatCounter)
	}
}

type mChatRepositoryMockGetChatIDByName struct {
	optional           bool
	mock               *ChatRepositoryMock
	defaultExpectation *ChatRepositoryMockGetChatIDByNameExpectation
	expectations       []*ChatRepositoryMockGetChatIDByNameExpectation

	callArgs []*ChatRepositoryMockGetChatIDByNameParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ChatRepositoryMockGetChatIDByNameExpectation specifies expectation struct of the ChatRepository.GetChatIDByName
type ChatRepositoryMockGetChatIDByNameExpectation struct {
	mock               *ChatRepositoryMock
	params             *ChatRepositoryMockGetChatIDByNameParams
	paramPtrs          *ChatRepositoryMockGetChatIDByNameParamPtrs
	expectationOrigins ChatRepositoryMockGetChatIDByNameExpectationOrigins
	results            *ChatRepositoryMockGetChatIDByNameResults
	returnOrigin       string
	Counter            uint64
}

// ChatRepositoryMockGetChatIDByNameParams contains parameters of the ChatRepository.GetChatIDByName
type ChatRepositoryMockGetChatIDByNameParams struct {
	ctx      context.Context
	chatname string
}

// ChatRepositoryMockGetChatIDByNameParamPtrs contains pointers to parameters of the ChatRepository.GetChatIDByName
type ChatRepositoryMockGetChatIDByNameParamPtrs struct {
	ctx      *context.Context
	chatname *string
}

// ChatRepositoryMockGetChatIDByNameResults contains results of the ChatRepository.GetChatIDByName
type ChatRepositoryMockGetChatIDByNameResults struct {
	i1  int64
	err error
}

// ChatRepositoryMockGetChatIDByNameOrigins contains origins of expectations of the ChatRepository.GetChatIDByName
type ChatRepositoryMockGetChatIDByNameExpectationOrigins struct {
	origin         string
	originCtx      string
	originChatname string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetChatIDByName *mChatRepositoryMockGetChatIDByName) Optional() *mChatRepositoryMockGetChatIDByName {
	mmGetChatIDByName.optional = true
	return mmGetChatIDByName
}

// Expect sets up expected params for ChatRepository.GetChatIDByName
func (mmGetChatIDByName *mChatRepositoryMockGetChatIDByName) Expect(ctx context.Context, chatname string) *mChatRepositoryMockGetChatIDByName {
	if mmGetChatIDByName.mock.funcGetChatIDByName != nil {
		mmGetChatIDByName.mock.t.Fatalf("ChatRepositoryMock.GetChatIDByName mock is already set by Set")
	}

	if mmGetChatIDByName.defaultExpectation == nil {
		mmGetChatIDByName.defaultExpectation = &ChatRepositoryMockGetChatIDByNameExpectation{}
	}

	if mmGetChatIDByName.defaultExpectation.paramPtrs != nil {
		mmGetChatIDByName.mock.t.Fatalf("ChatRepositoryMock.GetChatIDByName mock is already set by ExpectParams functions")
	}

	mmGetChatIDByName.defaultExpectation.params = &ChatRepositoryMockGetChatIDByNameParams{ctx, chatname}
	mmGetChatIDByName.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetChatIDByName.expectations {
		if minimock.Equal(e.params, mmGetChatIDByName.defaultExpectation.params) {
			mmGetChatIDByName.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetChatIDByName.defaultExpectation.params)
		}
	}

	return mmGetChatIDByName
}

// ExpectCtxParam1 sets up expected param ctx for ChatRepository.GetChatIDByName
func (mmGetChatIDByName *mChatRepositoryMockGetChatIDByName) ExpectCtxParam1(ctx context.Context) *mChatRepositoryMockGetChatIDByName {
	if mmGetChatIDByName.mock.funcGetChatIDByName != nil {
		mmGetChatIDByName.mock.t.Fatalf("ChatRepositoryMock.GetChatIDByName mock is already set by Set")
	}

	if mmGetChatIDByName.defaultExpectation == nil {
		mmGetChatIDByName.defaultExpectation = &ChatRepositoryMockGetChatIDByNameExpectation{}
	}

	if mmGetChatIDByName.defaultExpectation.params != nil {
		mmGetChatIDByName.mock.t.Fatalf("ChatRepositoryMock.GetChatIDByName mock is already set by Expect")
	}

	if mmGetChatIDByName.defaultExpectation.paramPtrs == nil {
		mmGetChatIDByName.defaultExpectation.paramPtrs = &ChatRepositoryMockGetChatIDByNameParamPtrs{}
	}
	mmGetChatIDByName.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetChatIDByName.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetChatIDByName
}

// ExpectChatnameParam2 sets up expected param chatname for ChatRepository.GetChatIDByName
func (mmGetChatIDByName *mChatRepositoryMockGetChatIDByName) ExpectChatnameParam2(chatname string) *mChatRepositoryMockGetChatIDByName {
	if mmGetChatIDByName.mock.funcGetChatIDByName != nil {
		mmGetChatIDByName.mock.t.Fatalf("ChatRepositoryMock.GetChatIDByName mock is already set by Set")
	}

	if mmGetChatIDByName.defaultExpectation == nil {
		mmGetChatIDByName.defaultExpectation = &ChatRepositoryMockGetChatIDByNameExpectation{}
	}

	if mmGetChatIDByName.defaultExpectation.params != nil {
		mmGetChatIDByName.mock.t.Fatalf("ChatRepositoryMock.GetChatIDByName mock is already set by Expect")
	}

	if mmGetChatIDByName.defaultExpectation.paramPtrs == nil {
		mmGetChatIDByName.defaultExpectation.paramPtrs = &ChatRepositoryMockGetChatIDByNameParamPtrs{}
	}
	mmGetChatIDByName.defaultExpectation.paramPtrs.chatname = &chatname
	mmGetChatIDByName.defaultExpectation.expectationOrigins.originChatname = minimock.CallerInfo(1)

	return mmGetChatIDByName
}

// Inspect accepts an inspector function that has same arguments as the ChatRepository.GetChatIDByName
func (mmGetChatIDByName *mChatRepositoryMockGetChatIDByName) Inspect(f func(ctx context.Context, chatname string)) *mChatRepositoryMockGetChatIDByName {
	if mmGetChatIDByName.mock.inspectFuncGetChatIDByName != nil {
		mmGetChatIDByName.mock.t.Fatalf("Inspect function is already set for ChatRepositoryMock.GetChatIDByName")
	}

	mmGetChatIDByName.mock.inspectFuncGetChatIDByName = f

	return mmGetChatIDByName
}

// Return sets up results that will be returned by ChatRepository.GetChatIDByName
func (mmGetChatIDByName *mChatRepositoryMockGetChatIDByName) Return(i1 int64, err error) *ChatRepositoryMock {
	if mmGetChatIDByName.mock.funcGetChatIDByName != nil {
		mmGetChatIDByName.mock.t.Fatalf("ChatRepositoryMock.GetChatIDByName mock is already set by Set")
	}

	if mmGetChatIDByName.defaultExpectation == nil {
		mmGetChatIDByName.defaultExpectation = &ChatRepositoryMockGetChatIDByNameExpectation{mock: mmGetChatIDByName.mock}
	}
	mmGetChatIDByName.defaultExpectation.results = &ChatRepositoryMockGetChatIDByNameResults{i1, err}
	mmGetChatIDByName.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetChatIDByName.mock
}

// Set uses given function f to mock the ChatRepository.GetChatIDByName method
func (mmGetChatIDByName *mChatRepositoryMockGetChatIDByName) Set(f func(ctx context.Context, chatname string) (i1 int64, err error)) *ChatRepositoryMock {
	if mmGetChatIDByName.defaultExpectation != nil {
		mmGetChatIDByName.mock.t.Fatalf("Default expectation is already set for the ChatRepository.GetChatIDByName method")
	}

	if len(mmGetChatIDByName.expectations) > 0 {
		mmGetChatIDByName.mock.t.Fatalf("Some expectations are already set for the ChatRepository.GetChatIDByName method")
	}

	mmGetChatIDByName.mock.funcGetChatIDByName = f
	mmGetChatIDByName.mock.funcGetChatIDByNameOrigin = minimock.CallerInfo(1)
	return mmGetChatIDByName.mock
}

// When sets expectation for the ChatRepository.GetChatIDByName which will trigger the result defined by the following
// Then helper
func (mmGetChatIDByName *mChatRepositoryMockGetChatIDByName) When(ctx context.Context, chatname string) *ChatRepositoryMockGetChatIDByNameExpectation {
	if mmGetChatIDByName.mock.funcGetChatIDByName != nil {
		mmGetChatIDByName.mock.t.Fatalf("ChatRepositoryMock.GetChatIDByName mock is already set by Set")
	}

	expectation := &ChatRepositoryMockGetChatIDByNameExpectation{
		mock:               mmGetChatIDByName.mock,
		params:             &ChatRepositoryMockGetChatIDByNameParams{ctx, chatname},
		expectationOrigins: ChatRepositoryMockGetChatIDByNameExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetChatIDByName.expectations = append(mmGetChatIDByName.expectations, expectation)
	return expectation
}

// Then sets up ChatRepository.GetChatIDByName return parameters for the expectation previously defined by the When method
func (e *ChatRepositoryMockGetChatIDByNameExpectation) Then(i1 int64, err error) *ChatRepositoryMock {
	e.results = &ChatRepositoryMockGetChatIDByNameResults{i1, err}
	return e.mock
}

// Times sets number of times ChatRepository.GetChatIDByName should be invoked
func (mmGetChatIDByName *mChatRepositoryMockGetChatIDByName) Times(n uint64) *mChatRepositoryMockGetChatIDByName {
	if n == 0 {
		mmGetChatIDByName.mock.t.Fatalf("Times of ChatRepositoryMock.GetChatIDByName mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetChatIDByName.expectedInvocations, n)
	mmGetChatIDByName.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetChatIDByName
}

func (mmGetChatIDByName *mChatRepositoryMockGetChatIDByName) invocationsDone() bool {
	if len(mmGetChatIDByName.expectations) == 0 && mmGetChatIDByName.defaultExpectation == nil && mmGetChatIDByName.mock.funcGetChatIDByName == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetChatIDByName.mock.afterGetChatIDByNameCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetChatIDByName.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetChatIDByName implements mm_repository.ChatRepository
func (mmGetChatIDByName *ChatRepositoryMock) GetChatIDByName(ctx context.Context, chatname string) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmGetChatIDByName.beforeGetChatIDByNameCounter, 1)
	defer mm_atomic.AddUint64(&mmGetChatIDByName.afterGetChatIDByNameCounter, 1)

	mmGetChatIDByName.t.Helper()

	if mmGetChatIDByName.inspectFuncGetChatIDByName != nil {
		mmGetChatIDByName.inspectFuncGetChatIDByName(ctx, chatname)
	}

	mm_params := ChatRepositoryMockGetChatIDByNameParams{ctx, chatname}

	// Record call args
	mmGetChatIDByName.GetChatIDByNameMock.mutex.Lock()
	mmGetChatIDByName.GetChatIDByNameMock.callArgs = append(mmGetChatIDByName.GetChatIDByNameMock.callArgs, &mm_params)
	mmGetChatIDByName.GetChatIDByNameMock.mutex.Unlock()

	for _, e := range mmGetChatIDByName.GetChatIDByNameMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmGetChatIDByName.GetChatIDByNameMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetChatIDByName.GetChatIDByNameMock.defaultExpectation.Counter, 1)
		mm_want := mmGetChatIDByName.GetChatIDByNameMock.defaultExpectation.params
		mm_want_ptrs := mmGetChatIDByName.GetChatIDByNameMock.defaultExpectation.paramPtrs

		mm_got := ChatRepositoryMockGetChatIDByNameParams{ctx, chatname}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetChatIDByName.t.Errorf("ChatRepositoryMock.GetChatIDByName got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetChatIDByName.GetChatIDByNameMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.chatname != nil && !minimock.Equal(*mm_want_ptrs.chatname, mm_got.chatname) {
				mmGetChatIDByName.t.Errorf("ChatRepositoryMock.GetChatIDByName got unexpected parameter chatname, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetChatIDByName.GetChatIDByNameMock.defaultExpectation.expectationOrigins.originChatname, *mm_want_ptrs.chatname, mm_got.chatname, minimock.Diff(*mm_want_ptrs.chatname, mm_got.chatname))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetChatIDByName.t.Errorf("ChatRepositoryMock.GetChatIDByName got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetChatIDByName.GetChatIDByNameMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetChatIDByName.GetChatIDByNameMock.defaultExpectation.results
		if mm_results == nil {
			mmGetChatIDByName.t.Fatal("No results are set for the ChatRepositoryMock.GetChatIDByName")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmGetChatIDByName.funcGetChatIDByName != nil {
		return mmGetChatIDByName.funcGetChatIDByName(ctx, chatname)
	}
	mmGetChatIDByName.t.Fatalf("Unexpected call to ChatRepositoryMock.GetChatIDByName. %v %v", ctx, chatname)
	return
}

// GetChatIDByNameAfterCounter returns a count of finished ChatRepositoryMock.GetChatIDByName invocations
func (mmGetChatIDByName *ChatRepositoryMock) GetChatIDByNameAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetChatIDByName.afterGetChatIDByNameCounter)
}

// GetChatIDByNameBeforeCounter returns a count of ChatRepositoryMock.GetChatIDByName invocations
func (mmGetChatIDByName *ChatRepositoryMock) GetChatIDByNameBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetChatIDByName.beforeGetChatIDByNameCounter)
}

// Calls returns a list of arguments used in each call to ChatRepositoryMock.GetChatIDByName.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetChatIDByName *mChatRepositoryMockGetChatIDByName) Calls() []*ChatRepositoryMockGetChatIDByNameParams {
	mmGetChatIDByName.mutex.RLock()

	argCopy := make([]*ChatRepositoryMockGetChatIDByNameParams, len(mmGetChatIDByName.callArgs))
	copy(argCopy, mmGetChatIDByName.callArgs)

	mmGetChatIDByName.mutex.RUnlock()

	return argCopy
}

// MinimockGetChatIDByNameDone returns true if the count of the GetChatIDByName invocations corresponds
// the number of defined expectations
func (m *ChatRepositoryMock) MinimockGetChatIDByNameDone() bool {
	if m.GetChatIDByNameMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetChatIDByNameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetChatIDByNameMock.invocationsDone()
}

// MinimockGetChatIDByNameInspect logs each unmet expectation
func (m *ChatRepositoryMock) MinimockGetChatIDByNameInspect() {
	for _, e := range m.GetChatIDByNameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatRepositoryMock.GetChatIDByName at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetChatIDByNameCounter := mm_atomic.LoadUint64(&m.afterGetChatIDByNameCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetChatIDByNameMock.defaultExpectation != nil && afterGetChatIDByNameCounter < 1 {
		if m.GetChatIDByNameMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ChatRepositoryMock.GetChatIDByName at\n%s", m.GetChatIDByNameMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ChatRepositoryMock.GetChatIDByName at\n%s with params: %#v", m.GetChatIDByNameMock.defaultExpectation.expectationOrigins.origin, *m.GetChatIDByNameMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetChatIDByName != nil && afterGetChatIDByNameCounter < 1 {
		m.t.Errorf("Expected call to ChatRepositoryMock.GetChatIDByName at\n%s", m.funcGetChatIDByNameOrigin)
	}

	if !m.GetChatIDByNameMock.invocationsDone() && afterGetChatIDByNameCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatRepositoryMock.GetChatIDByName at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetChatIDByNameMock.expectedInvocations), m.GetChatIDByNameMock.expectedInvocationsOrigin, afterGetChatIDByNameCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ChatRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateChatInspect()

			m.MinimockDeleteChatInspect()

			m.MinimockGetChatIDByNameInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ChatRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ChatRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateChatDone() &&
		m.MinimockDeleteChatDone() &&
		m.MinimockGetChatIDByNameDone()
}
